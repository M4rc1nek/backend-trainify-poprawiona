package com.trainify.trainifybackend.config;

import com.trainify.trainifybackend.exception.UserNotFoundException;
import com.trainify.trainifybackend.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
@RequiredArgsConstructor
public class ApplicationConfig {

    private final UserRepository userRepository; // Wstrzyknięcie repozytorium użytkowników

    //Wczytywanie  użytkownika i zwracanie uzytkownika z zahashowanym haslem i rolami
    @Bean
    public UserDetailsService userDetailsService() {
        return username -> userRepository.findByEmail(username) // Spring Security użyje "username", ale u nas to jest email
                .map(user -> org.springframework.security.core.userdetails.User.builder() // Mapowanie (zamiana) naszej klasy User na UserDetails
                        .username(user.getEmail())
                        .password(user.getPassword())
                        // W prostym projekcie nie używamy ról, ale jeśli chcesz, dodaj np. .roles("USER")
                        .build())
                .orElseThrow(() -> new UserNotFoundException("Nie znaleziono użytkownika"));
    }

    // 2. Provider uwierzytelniania, pobiera haslo od uzytkownika i prosi UserDetailsService o załadaowanie zahashowanego hasła z bazy
    // A nastepnie prosi PasswordEncoder o sprawdzenie czy te dwa hasla do siebie pasuja (cos typu .matches)
    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService()); // Ustawienie serwisu do ładowania użytkownika
        authProvider.setPasswordEncoder(passwordEncoder()); // Ustawienie kodera hasła
        return authProvider;
    }

    // 3. Manager uwierzytelniania (Kieruje
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception { // Uwierzytelnia uzytkownikow (np. sprawdzenie loginu, hasla)
        return config.getAuthenticationManager(); // zwraca w pełni skonfigurowany obiekt AuthenticationManager
    }

    // 4. Koder hasła
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
package com.trainify.trainifybackend.config;

import com.trainify.trainifybackend.security.JwtAuthenticationFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;
import java.util.List;

@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityFilterChainConfig {

    private final JwtAuthenticationFilter jwtAuthFilter;
    private final AuthenticationProvider authenticationProvider;


    //Polaczenie z frontendem
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();

        configuration.setAllowedOrigins(List.of("http://localhost:5173"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }


    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        //Włączenie CORS i wyłączenie CSRF
        http
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .csrf(csrf -> csrf.disable())

                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/register", "/login").permitAll() //register, /login → dostęp dla wszystkich (nie trzeba tokena JWT).
                        .requestMatchers("/training/**").authenticated() //training/** → dostęp tylko dla zalogowanych użytkowników (czyli muszą mieć ważny token JWT).
                        .requestMatchers("/contact").permitAll()
                        .requestMatchers("/api/pdf/**").authenticated()
                        .anyRequest().authenticated()    //anyRequest().authenticated() → każde inne żądanie też wymaga zalogowania.
                )
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) // „Nie twórz sesji, nie zapamiętuj zalogowanego użytkownika — wszystko opiera się na tokenie JWT"
                .authenticationProvider(authenticationProvider) // Mowi Springowi jak ma sprawdzac dane
                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class); // Wstaw mój filtr JWT przed tym standardowym, żeby token był sprawdzony, zanim Spring zacznie swoje logowanie

        return http.build();
    }
}
package com.trainify.trainifybackend.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("http://localhost:5173")
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(true);
    }
}
package com.trainify.trainifybackend.contact.controller;

import com.trainify.trainifybackend.contact.dto.ContactDTO;
import com.trainify.trainifybackend.contact.service.ContactService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequiredArgsConstructor
public class ContactController {

    private final ContactService contactService;


    @PostMapping("/contact")
    public ResponseEntity<Void> sendMessage(@Valid @RequestBody ContactDTO contactDTO){
        contactService.sendContactEmail(contactDTO);
        return ResponseEntity.ok().build();
    }

}
package com.trainify.trainifybackend.contact.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

public record ContactDTO(
        @NotBlank String name,
        @NotBlank String message,
        @NotBlank String subject,
        @Email String email
) {
}
package com.trainify.trainifybackend.contact.service;

import com.trainify.trainifybackend.contact.dto.ContactDTO;
import lombok.RequiredArgsConstructor;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

@Async
@Service
@RequiredArgsConstructor
public class ContactService {

   private final JavaMailSender mailSender;

   public void sendContactEmail(ContactDTO dto){
       SimpleMailMessage message = new SimpleMailMessage();
       // Adres odbiorcy — Twój mail administratora
       message.setTo("getrespectstudio@gmail.com");
       // Temat wiadomości
       message.setSubject(dto.subject());
       message.setReplyTo(dto.email()); // // Ustawiamy adres osoby, która wysłała formularz, dzięki temu w Gmailu klikniesz "Odpowiedz" i mail pójdzie do użytkownika
       message.setText(
               "Od: " + dto.name() + " (" + dto.email() + ")\n\n" + dto.message() // Treść wiadomości, czyli dane wysłane w formularzu
       );
       mailSender.send(message);

   }

}
package com.trainify.trainifybackend.dailywellness.controller;

import com.trainify.trainifybackend.dailywellness.dto.DailyWellnessDTO;
import com.trainify.trainifybackend.dailywellness.service.DailyWellnessService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.util.List;

@RestController
@RequiredArgsConstructor
public class DailyWellnessController {

    private final DailyWellnessService dailyWellnessService;

    @PostMapping("/daily-wellness/submit")
    public ResponseEntity<DailyWellnessDTO> submitCheck(@RequestBody @Valid DailyWellnessDTO dto) {
        String userEmail = SecurityContextHolder.getContext().getAuthentication().getName();
        return ResponseEntity.ok(dailyWellnessService.submitCheck(dto, userEmail));
    }

    @GetMapping("/daily-wellness/history")
    public ResponseEntity<List<DailyWellnessDTO>> getDailyWellnessHistory() {
        String userEmail = SecurityContextHolder.getContext().getAuthentication().getName();
        return ResponseEntity.ok(dailyWellnessService.getDailyWellnessHistory(userEmail));
    }

    @DeleteMapping("/daily-wellness/{userId}")
    public ResponseEntity<Void> deleteDailyWellness(@PathVariable Long userId, @RequestParam LocalDate date) {
        dailyWellnessService.deleteDailyWellness(userId, date);
        return ResponseEntity.noContent().build();
    }

    @PutMapping("/daily-wellness/{userId}")
    public ResponseEntity<DailyWellnessDTO> updateDailyWellness(@RequestBody @Valid DailyWellnessDTO dto, @PathVariable Long userId, @RequestParam LocalDate date) {
        return ResponseEntity.ok(dailyWellnessService.updateDailyWellness(dto, userId, date));
    }

}
package com.trainify.trainifybackend.dailywellness.dto;

import com.trainify.trainifybackend.dailywellness.model.ReadinessLevel;
import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.PastOrPresent;

import java.time.LocalDate;

public record DailyWellnessDTO(

        Long id,

        @PastOrPresent LocalDate date,


        @Min(0) @Max(24) double hoursSlept,
        @Min(1) @Max(10) int energyLevel,
        @Min(1) @Max(10) int musclePain,
        @Min(1) @Max(10) int mood,
        @Min(1) @Max(10) int motivation,

        int readinessScore,
        ReadinessLevel readinessLevel,
        String recommendation
) {
}
package com.trainify.trainifybackend.dailywellness.model;


import com.trainify.trainifybackend.user.model.User;
import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDate;

@Builder
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Entity
public class DailyWellness {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private LocalDate date;

    private double hoursSlept;
    private int energyLevel;
    private int musclePain;
    private int mood;
    private int motivation;

    private int readinessScore; // Wynik oceny gotowości użytkownika w skali 0-100, wyliczany z 5 parametrów.
    private ReadinessLevel readinessLevel; // Poziom gotowości: "WYSOKI", "ŚREDNI" lub "NISKI".
    private String recommendation; // Krótka rekomendacja treningowa na podstawie wyniku.




    @ManyToOne
    @JoinColumn(name = "user_id")
    private User userAssigned;

}
package com.trainify.trainifybackend.dailywellness.model;

public enum ReadinessLevel {
    Wysoki,
    Średni,
    Niski

}
package com.trainify.trainifybackend.dailywellness.repository;

import com.trainify.trainifybackend.dailywellness.model.DailyWellness;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

public interface DailyWellnessRepository extends JpaRepository<DailyWellness, Long> {



    // Pobiera pojedynczy wpis DailyWellness dla konkretnego użytkownika (userId) w określonym dniu (date).
    // Zwraca Optional, bo wpis może istnieć lub nie.
    @Query("SELECT d FROM DailyWellness d WHERE d.userAssigned.id = :userId AND d.date = :date")
    Optional<DailyWellness> findByUserAssigned_IdAndDate(@Param("userId") Long userId, @Param("date") LocalDate date);



    // Pobiera wszystkie wpisy DailyWellness dla konkretnego użytkownika (userId)
    // i zwraca je posortowane od najnowszego do najstarszego według daty.
    @Query("SELECT d FROM DailyWellness d WHERE d.userAssigned.id = :userId ORDER BY d.date DESC")
    List<DailyWellness> findAllByUserAssigned_IdOrderByDateDesc(@Param("userId") Long userId);


}
package com.trainify.trainifybackend.dailywellness.service;


import com.trainify.trainifybackend.dailywellness.dto.DailyWellnessDTO;
import com.trainify.trainifybackend.dailywellness.model.DailyWellness;
import com.trainify.trainifybackend.dailywellness.model.ReadinessLevel;
import com.trainify.trainifybackend.dailywellness.repository.DailyWellnessRepository;
import com.trainify.trainifybackend.exception.DailyWellnessAlreadySubmittedException;
import com.trainify.trainifybackend.exception.DailyWellnessForUserNotFoundException;
import com.trainify.trainifybackend.exception.UserNotFoundException;
import com.trainify.trainifybackend.user.model.User;
import com.trainify.trainifybackend.user.repository.UserRepository;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.List;

@Service
@RequiredArgsConstructor
public class DailyWellnessService {

    private final DailyWellnessRepository dailyWellnessRepository;
    private final UserRepository userRepository;

    @Transactional
    public DailyWellnessDTO submitCheck(DailyWellnessDTO dto, String email) {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException("Nie znaleziono użytkownika"));


        dailyWellnessRepository.findByUserAssigned_IdAndDate(user.getId(), LocalDate.now())
                .ifPresent(w -> {
                    throw new DailyWellnessAlreadySubmittedException("Dzisiaj formularz został już wypełniony");
                });


        int readinessScore = calculateReadiness(dto);
        ReadinessLevel readinessLevel = determineReadinessLevel(readinessScore);
        String recommendation = generateRecommendation(readinessLevel);


        DailyWellness dailyWellness = DailyWellness.builder()
                .date(LocalDate.now()) //LocalDate.now() zamiast dto.date() -> dlatego aby data była pobierana z teraz, żeby użytkownik nie mógł wpisać np. date jutrzejszą
                .hoursSlept(dto.hoursSlept())
                .energyLevel(dto.energyLevel())
                .musclePain(dto.musclePain())
                .mood(dto.mood())
                .motivation(dto.motivation())
                .readinessScore(readinessScore)
                .readinessLevel(readinessLevel)
                .recommendation(recommendation)
                .userAssigned(user)
                .build();

        dailyWellnessRepository.save(dailyWellness);

        return new DailyWellnessDTO(
                dailyWellness.getId(),
                dailyWellness.getDate(),
                dailyWellness.getHoursSlept(),
                dailyWellness.getEnergyLevel(),
                dailyWellness.getMusclePain(),
                dailyWellness.getMood(),
                dailyWellness.getMotivation(),
                dailyWellness.getReadinessScore(),
                dailyWellness.getReadinessLevel(),
                dailyWellness.getRecommendation()
        );
    }

    public List<DailyWellnessDTO> getDailyWellnessHistory(String email) {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException("Nie znaleziono użytkownika"));
        List<DailyWellness> history = dailyWellnessRepository.findAllByUserAssigned_IdOrderByDateDesc(user.getId());

        return history.stream()
                .map(d -> new DailyWellnessDTO(
                        d.getId(),
                        d.getDate(),
                        d.getHoursSlept(),
                        d.getEnergyLevel(),
                        d.getMusclePain(),
                        d.getMood(),
                        d.getMotivation(),
                        d.getReadinessScore(),
                        d.getReadinessLevel(),
                        d.getRecommendation()
                ))
                .toList();
    }

    @Transactional
    public DailyWellnessDTO updateDailyWellness(DailyWellnessDTO dto, Long userId, LocalDate date) {
       DailyWellness existing = dailyWellnessRepository.findByUserAssigned_IdAndDate(userId, date)
                .orElseThrow(() -> new DailyWellnessForUserNotFoundException("Nie znaleziono DailyWellness dla użytkownika o ID: " + userId + " w dniu " + date));

        int readinessScore = calculateReadiness(dto);
        ReadinessLevel readinessLevel = determineReadinessLevel(readinessScore);
        String recommendation = generateRecommendation(readinessLevel);


        DailyWellness updatedDailyWellness = DailyWellness.builder()
                .id(existing.getId())
                .userAssigned(existing.getUserAssigned())
                .date(dto.date())
                .hoursSlept(dto.hoursSlept())
                .energyLevel(dto.energyLevel())
                .musclePain(dto.musclePain())
                .mood(dto.mood())
                .motivation(dto.motivation())
                .readinessScore(readinessScore)
                .readinessLevel(readinessLevel)
                .recommendation(recommendation)
                .build();


        DailyWellness saved =  dailyWellnessRepository.save(updatedDailyWellness);


        return new DailyWellnessDTO(
                saved.getId(),
                saved.getDate(),
                saved.getHoursSlept(),
                saved.getEnergyLevel(),
                saved.getMusclePain(),
                saved.getMood(),
                saved.getMotivation(),
                saved.getReadinessScore(),
                saved.getReadinessLevel(),
                saved.getRecommendation()
        );
    }


    public void deleteDailyWellness(Long userId, LocalDate date) {
        DailyWellness dailyWellness = dailyWellnessRepository.findByUserAssigned_IdAndDate(userId, date)
                .orElseThrow(() -> new DailyWellnessForUserNotFoundException("Nie znaleziono DailyWellness dla użytkownika o ID: " + userId + " w dniu " + date));
        dailyWellnessRepository.delete(dailyWellness);
    }


    private int calculateReadiness(DailyWellnessDTO dto) {

        double sleepPoints;

        if (dto.hoursSlept() >= 8) sleepPoints = 30;
        else if (dto.hoursSlept() >= 7) sleepPoints = 25;
        else if (dto.hoursSlept() >= 6) sleepPoints = 15;
        else sleepPoints = 5;

        double energyPoints = (dto.energyLevel() / 10.0) * 25;
        double musclePainPoints = ((10 - dto.musclePain()) / 10.0) * 25;
        double moodPoints = (dto.mood() / 10.0) * 15;
        double motivationPoints = (dto.motivation() / 10.0) * 10;


        return (int) Math.round(sleepPoints + energyPoints + musclePainPoints + moodPoints + motivationPoints);

    }

    private ReadinessLevel determineReadinessLevel(int score) {
        if (score >= 70) return ReadinessLevel.Wysoki;
        else if (score >= 49) return ReadinessLevel.Średni;
        else return ReadinessLevel.Niski;
    }

    private String generateRecommendation(ReadinessLevel readinessLevel) {
        return switch (readinessLevel) {
            case Wysoki -> "Możesz trenować ciężko";
            case Średni -> "Trenuj ostrożnie, słuchaj ciała";
            default -> "Ciało potrzebuje regeneracji, nie trenuj";
        };

    }

}
package com.trainify.trainifybackend.exception;

public class DailyWellnessAlreadySubmittedException extends RuntimeException {
    public DailyWellnessAlreadySubmittedException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.exception;

public class DailyWellnessForUserNotFoundException extends RuntimeException {
    public DailyWellnessForUserNotFoundException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.exception;

public class EmailAlreadyExistsException extends RuntimeException {
    public EmailAlreadyExistsException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.exception;

public record ErrorResponseDTO(
        int status,      // kod HTTP (np. 400, 404, 500)
        String error,    // krótki opis błędu (np. "Bad Request")
        String message,  // szczegółowy komunikat (np. "Email jest już zajęty")
        String path,     // endpoint który wywołał bląd np ("/register")
        long timestamp   // czas w milisekundach od 01.01.1970 (Unix epoch), kiedy wyjątek wystąpił.,
        // Przykład: 1734500000000 → ułatwia debugowanie i śledzenie w logach
) {

    // Konstruktor ułatwiający ustawienie timestamp automatycznie
    public ErrorResponseDTO(int status, String error, String message, String path){
        this(status,error,message,path, System.currentTimeMillis());
    }
}
package com.trainify.trainifybackend.exception;


import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.context.request.WebRequest;

@RestControllerAdvice // -> Działa globalnie na wszystkie kontrolery, zwraca JSON
public class GlobalExceptionHandler {


    /*
           CONFLICT (409) → konflikt danych (np. email już istnieje)
           NOT_FOUND (404) → brak danych (np. użytkownik nie istnieje)
           BAD_REQUEST (400) → błędne dane wejściowe (np. niepoprawny format)
           UNAUTHORIZED (401) → nieprawidłowe logowanie lub brak autoryzacji
           UNPROCESSABLE_ENTITY (422) ->  dane są poprawne, ale operacja nie może zostać wykonana z powodów biznesowych (brakuje czegoś ważnego)
                          (np. próba obliczenia TDEE bez wcześniejszego obliczenia BMR)

    webRequest.getDescription(false) - Pobiera opis żądania path, np.  /register lub /login
    Jeśli dasz true, wynik zawierałby też informacje o kliencie (np. IP, host)
     */

    @ExceptionHandler({EmailAlreadyExistsException.class, UsernameAlreadyExistsException.class, DailyWellnessAlreadySubmittedException.class})
    public ResponseEntity<ErrorResponseDTO> handleConflictExceptions(RuntimeException exception, WebRequest webRequest) {
        ErrorResponseDTO body = new ErrorResponseDTO(
                HttpStatus.CONFLICT.value(),
                HttpStatus.CONFLICT.getReasonPhrase(),
                exception.getMessage(),
                webRequest.getDescription(false).replace("uri=", "")
        );
        return new ResponseEntity<>(body, HttpStatus.CONFLICT);
    }


    @ExceptionHandler({TrainingForUserNotFoundException.class, UserNotFoundException.class, DailyWellnessForUserNotFoundException.class, UserHealthMetricsNotFoundException.class})
    public ResponseEntity<ErrorResponseDTO> handleNotFoundExceptions(RuntimeException exception, WebRequest webRequest) {
        ErrorResponseDTO body = new ErrorResponseDTO(
                HttpStatus.NOT_FOUND.value(),
                HttpStatus.NOT_FOUND.getReasonPhrase(),
                exception.getMessage(),
                webRequest.getDescription(false).replace("uri=", "")
        );
        return new ResponseEntity<>(body, HttpStatus.NOT_FOUND);
    }


    @ExceptionHandler(WrongPasswordException.class)
    public ResponseEntity<ErrorResponseDTO> handleWrongPassword(WrongPasswordException exception, WebRequest webRequest) {
        ErrorResponseDTO body = new ErrorResponseDTO(
                HttpStatus.UNAUTHORIZED.value(),
                HttpStatus.UNAUTHORIZED.getReasonPhrase(),
                exception.getMessage(),
                webRequest.getDescription(false).replace("uri=", "")
        );
        return new ResponseEntity<>(body, HttpStatus.UNAUTHORIZED);
    }


    @ExceptionHandler(InvalidEnumValueException.class)
    public ResponseEntity<ErrorResponseDTO> handleInvalidEnumValue(InvalidEnumValueException exception, WebRequest webRequest) {
        ErrorResponseDTO body = new ErrorResponseDTO(
                HttpStatus.BAD_REQUEST.value(),
                HttpStatus.BAD_REQUEST.getReasonPhrase(),
                exception.getMessage(),
                webRequest.getDescription(false).replace("uri=", "")
        );
        return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);
    }


    @ExceptionHandler(MissingRequirementException.class)
    public ResponseEntity<ErrorResponseDTO> handleMissingRequirement(MissingRequirementException exception, WebRequest webRequest){
        ErrorResponseDTO body = new ErrorResponseDTO(
                HttpStatus.UNPROCESSABLE_ENTITY.value(),
                HttpStatus.UNPROCESSABLE_ENTITY.getReasonPhrase(),
                exception.getMessage(),
                webRequest.getDescription(false).replace("uri=", "")
        );
        return new ResponseEntity<>(body, HttpStatus.UNPROCESSABLE_ENTITY);
    }



    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponseDTO> handleAll(Exception exception, WebRequest webRequest) {
        ErrorResponseDTO body = new ErrorResponseDTO(
                HttpStatus.INTERNAL_SERVER_ERROR.value(),
                HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase(),
                "Wystąpił nieoczekiwany błąd. Skontaktuj się z administratorem.",
                webRequest.getDescription(false).replace("uri=", "")
        );
        return new ResponseEntity<>(body, HttpStatus.INTERNAL_SERVER_ERROR);
    }


}
package com.trainify.trainifybackend.exception;

public class InvalidEnumValueException extends RuntimeException {
    public InvalidEnumValueException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.exception;

public class MissingRequirementException extends RuntimeException {
    public MissingRequirementException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.exception;

public class TrainingForUserNotFoundException extends RuntimeException {
    public TrainingForUserNotFoundException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.exception;

public class UserHealthMetricsNotFoundException extends RuntimeException {
    public UserHealthMetricsNotFoundException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.exception;

public class UsernameAlreadyExistsException extends RuntimeException {
    public UsernameAlreadyExistsException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.exception;

public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.exception;

public class WrongPasswordException extends RuntimeException {
    public WrongPasswordException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.healthcore.controller;


import com.trainify.trainifybackend.healthcore.dto.MacronutrientsDTO;
import com.trainify.trainifybackend.healthcore.dto.UserHealthMetricsDTO;
import com.trainify.trainifybackend.healthcore.model.UserHealthMetrics;
import com.trainify.trainifybackend.healthcore.service.HealthCalculatorService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequiredArgsConstructor
public class UserHealthMetricsController {

    private final HealthCalculatorService healthCalculatorService;

    @PostMapping("/addBMI/{userId}")
    public ResponseEntity<UserHealthMetricsDTO> addBMI(@RequestBody @Valid UserHealthMetricsDTO dto, @PathVariable Long userId) {
        UserHealthMetrics metrics = healthCalculatorService.buildBMI(dto, userId);
        return ResponseEntity.ok(healthCalculatorService.mapToDTO(metrics));
    }


    @PostMapping("/addBMR/{userId}")
    public ResponseEntity<UserHealthMetricsDTO> addBMR(@RequestBody @Valid UserHealthMetricsDTO dto, @PathVariable Long userId) {
        UserHealthMetrics metrics = healthCalculatorService.buildBMR(dto, userId);
        return ResponseEntity.ok(healthCalculatorService.mapToDTO(metrics));
    }


    @PostMapping("/addTDEE/{userId}")
    public ResponseEntity<UserHealthMetricsDTO> addTDEE(@RequestBody @Valid UserHealthMetricsDTO dto, @PathVariable Long userId){
        UserHealthMetrics metrics = healthCalculatorService.buildTDEE(dto, userId);
        return ResponseEntity.ok(healthCalculatorService.mapToDTO(metrics));
    }

    @PostMapping("/addMacro/{userId}")
    public ResponseEntity<UserHealthMetricsDTO> addMacro(@RequestBody @Valid UserHealthMetricsDTO dto, @PathVariable Long userId){
        UserHealthMetrics metrics = healthCalculatorService.buildMacronutrients(dto, userId);
        return ResponseEntity.ok(healthCalculatorService.mapToDTO(metrics));
    }

    @GetMapping("/getBMI/{userId}")
    public ResponseEntity<Double> getBMI(@PathVariable Long userId) {
        return ResponseEntity.ok(healthCalculatorService.getBMI(userId));
    }


    @GetMapping("/getBMR/{userId}")
    public ResponseEntity<Double> getBMR(@PathVariable Long userId) {
        return ResponseEntity.ok(healthCalculatorService.getBMR(userId));
    }


    @GetMapping("/getTDEE/{userId}")
    public ResponseEntity<Double> getTDEE(@PathVariable Long userId) {
        return ResponseEntity.ok(healthCalculatorService.getTDEE(userId));
    }

    @GetMapping("/getMacro/{userId}")
    public ResponseEntity<MacronutrientsDTO> getMacronutrients(@PathVariable Long userId){
        return ResponseEntity.ok(healthCalculatorService.getMacronutrients(userId));
    }
}

package com.trainify.trainifybackend.healthcore.dto;

public record MacronutrientsDTO(
        double protein,
        double fats,
        double carbohydrates
) {
}
package com.trainify.trainifybackend.healthcore.dto;

import com.trainify.trainifybackend.healthcore.model.ActivityLevel;
import com.trainify.trainifybackend.healthcore.model.BmiFeedback;
import com.trainify.trainifybackend.healthcore.model.GenderType;
import com.trainify.trainifybackend.healthcore.model.GoalType;
import jakarta.validation.constraints.DecimalMax;
import jakarta.validation.constraints.DecimalMin;

public record UserHealthMetricsDTO(

        Long id,


        ActivityLevel activityLevel,
        GenderType genderType,
        GoalType goalType,


        int age,
        @DecimalMin("1.0") @DecimalMax("250.0") double height, // cm
        @DecimalMin("30.0") @DecimalMax("300.0") double weight, // kg

        double BMI,
        double BMR,
        double TDEE,
        BmiFeedback bmiFeedback

) {
}
package com.trainify.trainifybackend.healthcore.model;

public enum ActivityLevel {
    Brak,
    Niski,
    Umiarkowany,
    Wysoki,
    Ekstremalny,
}
package com.trainify.trainifybackend.healthcore.model;

public enum BmiFeedback {
    niedowaga,
    prawidłowa,
    nadwaga,
    otyłość
}
package com.trainify.trainifybackend.healthcore.model;

public enum GenderType {
    Mężczyzna,
    Kobieta
}
package com.trainify.trainifybackend.healthcore.model;

public enum GoalType {
    Redukcja,
    Utrzymanie,
    Masa
}
package com.trainify.trainifybackend.healthcore.model;

import com.trainify.trainifybackend.user.model.User;
import jakarta.persistence.*;
import lombok.*;

@AllArgsConstructor
@NoArgsConstructor
@Entity
@Builder
@Getter
@Setter
public class UserHealthMetrics {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private int age;

    private double height; // metry
    private double weight;

    private GenderType genderType;
    private GoalType goalType;

    @Enumerated(EnumType.STRING)
    private ActivityLevel activityLevel;

    private double BMI;
    private double BMR;
    private double TDEE;


    private double protein;
    private double carbohydrates;
    private double fats;

    private double macro;

    private BmiFeedback bmiFeedback;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User userAssigned;


}
package com.trainify.trainifybackend.healthcore.repository;

import com.trainify.trainifybackend.healthcore.model.UserHealthMetrics;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface HealthCoreRepository extends JpaRepository<UserHealthMetrics, Long> {

    Optional<UserHealthMetrics> findTopByUserAssigned_IdOrderByIdDesc(Long userId);
}
package com.trainify.trainifybackend.healthcore.service;

import com.trainify.trainifybackend.exception.InvalidEnumValueException;
import com.trainify.trainifybackend.exception.MissingRequirementException;
import com.trainify.trainifybackend.exception.UserHealthMetricsNotFoundException;
import com.trainify.trainifybackend.exception.UserNotFoundException;
import com.trainify.trainifybackend.healthcore.dto.MacronutrientsDTO;
import com.trainify.trainifybackend.healthcore.dto.UserHealthMetricsDTO;
import com.trainify.trainifybackend.healthcore.model.*;
import com.trainify.trainifybackend.healthcore.repository.HealthCoreRepository;
import com.trainify.trainifybackend.user.model.User;
import com.trainify.trainifybackend.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class HealthCalculatorService {

    private final UserRepository userRepository;
    private final HealthCoreRepository healthCoreRepository;


    public User getUserOrThrow(Long userId) {
        return userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("Nie znaleziono użytkownika o id " + userId));
    }

    public UserHealthMetrics buildMetrics(Long userId) {
        //Szukasz ostatnich metryk użytkownika (BMI, BMR, TDEE), jeśli są to je zwracasz, jeśli nie ma idzie przechodzisz do .orElseGet
        return healthCoreRepository.findTopByUserAssigned_IdOrderByIdDesc(userId)
                .orElseGet(() -> { //Tworzysz ogólny szkielet metryk, który przypisujesz do użytkownika
                    User user = getUserOrThrow(userId);
                    return UserHealthMetrics.builder()
                            .userAssigned(user)
                            .build();
                }); // Dzięki szkieletowi w innych metodach wystarczy tylko ustawić brakujące wartości, zamiast zawsze tworzyć nowy obiekt.

        //Zamiast zawsze tworzyć nowe metryki, orElseGet zostanie wywołane tylko wtedy, gdy nie znajdziemy istniejących metryk.


    }

    public UserHealthMetrics buildBMI(UserHealthMetricsDTO dto, Long userId) {
        UserHealthMetrics userHealthMetrics = buildMetrics(userId);

        userHealthMetrics.setHeight(dto.height());
        userHealthMetrics.setWeight(dto.weight());
        calculateBMI(userHealthMetrics);

        healthCoreRepository.save(userHealthMetrics);

        return userHealthMetrics;
    }

    public UserHealthMetrics buildBMR(UserHealthMetricsDTO dto, Long userId) {
        UserHealthMetrics userHealthMetrics = buildMetrics(userId);

        userHealthMetrics.setHeight(dto.height());
        userHealthMetrics.setWeight(dto.weight());
        userHealthMetrics.setAge(dto.age());
        userHealthMetrics.setGenderType(dto.genderType());

        calculateBMR(userHealthMetrics);
        healthCoreRepository.save(userHealthMetrics);

        return userHealthMetrics;
    }

    public UserHealthMetrics buildTDEE(UserHealthMetricsDTO dto, Long userId) {
        UserHealthMetrics userHealthMetrics = buildMetrics(userId);

        if (userHealthMetrics.getBMR() == 0.0) {
            throw new MissingRequirementException("Przed obliczeniem TDEE musisz najpierw obliczyć BMR");
        }
        userHealthMetrics.setActivityLevel(dto.activityLevel());

        if (userHealthMetrics.getActivityLevel() == null) {
            throw new MissingRequirementException("ActivityLevel nie może być puste przy liczeniu TDEE");
        }
        calculateTDEE(userHealthMetrics);
        healthCoreRepository.save(userHealthMetrics);

        return userHealthMetrics;
    }

    public UserHealthMetrics buildMacronutrients(UserHealthMetricsDTO dto, Long userId) {
        UserHealthMetrics userHealthMetrics = buildMetrics(userId);


        if (userHealthMetrics.getTDEE() == 0) {
            calculateTDEE(userHealthMetrics);
        }
        userHealthMetrics.setGoalType(dto.goalType());
        if (userHealthMetrics.getGoalType() == null) {
            throw new MissingRequirementException("Cel nie może być pusty");
        }


        calculateMacronutrients(userHealthMetrics);
        healthCoreRepository.save(userHealthMetrics);

        return userHealthMetrics;
    }


    public UserHealthMetricsDTO mapToDTO(UserHealthMetrics metrics) {
        return new UserHealthMetricsDTO(
                metrics.getId(),
                metrics.getActivityLevel(),
                metrics.getGenderType(),
                metrics.getGoalType(),
                metrics.getAge(),
                metrics.getHeight(),
                metrics.getWeight(),
                metrics.getBMI(),
                metrics.getBMR(),
                metrics.getTDEE(),
                metrics.getBmiFeedback()
        );
    }


    public UserHealthMetrics getMetricsOrThrow(Long userId) {
        return healthCoreRepository.findTopByUserAssigned_IdOrderByIdDesc(userId)
                .orElseThrow(() -> new UserHealthMetricsNotFoundException("Brak zapisanych metryk zdrowotnych dla użytkownika o id: " + userId));
    }

    public double getBMI(Long userId) {
        return getMetricsOrThrow(userId).getBMI();
    }

    public double getBMR(Long userId) {
        return getMetricsOrThrow(userId).getBMR();
    }

    public double getTDEE(Long userId) {
        return getMetricsOrThrow(userId).getTDEE();
    }

    public MacronutrientsDTO getMacronutrients(Long userId) {
       UserHealthMetrics metrics =  getMetricsOrThrow(userId);
        return new MacronutrientsDTO(metrics.getProtein(), metrics.getFats(), metrics.getCarbohydrates());
    }


    private void calculateBMI(UserHealthMetrics userHealthMetrics) {
        double heightInMeters = userHealthMetrics.getHeight() / 100.0;
        double BMI = userHealthMetrics.getWeight() / (heightInMeters * heightInMeters);

        BmiFeedback feedback;

        if (BMI < 18.5) feedback = BmiFeedback.niedowaga;
        else if (BMI <= 24.9) feedback = BmiFeedback.prawidłowa;
        else if (BMI <= 29.9) feedback = BmiFeedback.nadwaga;
        else feedback = BmiFeedback.otyłość;


        userHealthMetrics.setBMI(BMI);
        userHealthMetrics.setBmiFeedback(feedback);
    }


    private void calculateBMR(UserHealthMetrics userHealthMetrics) {

        GenderType genderType = userHealthMetrics.getGenderType();
        double BMR;

        switch (genderType) {
            case Mężczyzna ->
                    BMR = 10 * userHealthMetrics.getWeight() + 6.25 * userHealthMetrics.getHeight() - 5 * userHealthMetrics.getAge() + 5;
            case Kobieta ->
                    BMR = 10 * userHealthMetrics.getWeight() + 6.25 * userHealthMetrics.getHeight() - 5 * userHealthMetrics.getAge() - 161;
            default -> throw new InvalidEnumValueException("Nie ma takiej płci:  " + genderType);
        }

        userHealthMetrics.setBMR(BMR);

    }

    private void calculateTDEE(UserHealthMetrics userHealthMetrics) {

        ActivityLevel activityLevel = userHealthMetrics.getActivityLevel();
        double PAL; // to samo co activityLevel ale wartości nie enum (Physical Activity Level)

        switch (activityLevel) {
            case Brak -> PAL = 1.2;
            case Niski -> PAL = 1.375;
            case Umiarkowany -> PAL = 1.55;
            case Wysoki -> PAL = 1.7;
            case Ekstremalny -> PAL = 1.9;
            default -> throw new InvalidEnumValueException("Nie ma takiej aktywności:  " + activityLevel);
        }

        double TDEE = userHealthMetrics.getBMR() * PAL;

        userHealthMetrics.setTDEE(TDEE);


    }

    //macronutrients -> makrosładniki
    private void calculateMacronutrients(UserHealthMetrics userHealthMetrics) {
        GoalType goalType = userHealthMetrics.getGoalType();


        double proteinCalories, fatCalories, carbCalories;
        calculateTDEE(userHealthMetrics);
        //zapotrzebowanie kaloryczne
        double caloricRequirement = userHealthMetrics.getTDEE();
        switch (goalType) {
            case Redukcja -> {
                proteinCalories = caloricRequirement * 0.3;
                fatCalories = caloricRequirement * 0.25;
                carbCalories = caloricRequirement * 0.45;
            }
            case Utrzymanie -> {
                proteinCalories = caloricRequirement * 0.3;
                fatCalories = caloricRequirement * 0.2;
                carbCalories = caloricRequirement * 0.5;
            }
            case Masa -> {
                proteinCalories = caloricRequirement * 0.25;
                fatCalories = caloricRequirement * 0.25;
                carbCalories = caloricRequirement * 0.5;
            }
            default -> throw new InvalidEnumValueException("Nie ma takiego celu " + goalType);
        }
        double proteinInGrams = proteinCalories / 4;
        double carbohydratesInGrams = carbCalories / 4;
        double fatsInGrams = fatCalories / 9;


        userHealthMetrics.setProtein(proteinInGrams);
        userHealthMetrics.setFats(fatsInGrams);
        userHealthMetrics.setCarbohydrates(carbohydratesInGrams);

    }


}
package com.trainify.trainifybackend.pdfexport.controller;

import com.trainify.trainifybackend.pdfexport.service.PdfExportService;
import com.trainify.trainifybackend.training.dto.TrainingDTO;
import com.trainify.trainifybackend.training.service.TrainingService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping("/api/pdf")
@RequiredArgsConstructor
public class PdfExportController {

    private final PdfExportService pdfExportService;
    private final TrainingService trainingService;

    @GetMapping("/trainingsPdf")
    public ResponseEntity<byte[]> getTrainingsPdf(@RequestParam String email) {

        //Wyciągasz treningi dla użytkownika po emailu
        List<TrainingDTO> trainings = trainingService.getTrainingsForUserByEmail(email);

        byte[] pdfBytes = pdfExportService.generateTrainingsPdf(trainings); // wywolanie serwisu ktory tworzy PDF

        //Dzięki temu przeglądarka wie, że odpowiedź to plik PDF do pobrania z nazwą weekly_trainings.pdf
        HttpHeaders httpHeaders = new HttpHeaders();
        httpHeaders.setContentType(MediaType.APPLICATION_PDF);
        httpHeaders.setContentDispositionFormData("attachment", "trainings_history.pdf");

        return ResponseEntity.ok()
                .headers(httpHeaders)
                .body(pdfBytes);
    }
}
package com.trainify.trainifybackend.pdfexport.service;

import com.trainify.trainifybackend.training.dto.TrainingDTO;
import com.trainify.trainifybackend.training.dto.TrainingExerciseDTO;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.pdmodel.PDPage;
import org.apache.pdfbox.pdmodel.PDPageContentStream;
import org.apache.pdfbox.pdmodel.font.PDType0Font;
import org.springframework.stereotype.Service;

import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.util.List;

@Service
public class PdfExportService {

    public byte[] generateTrainingsPdf(List<TrainingDTO> trainings) { // byte dlatego ze pliki PDF operuja na byte


        if (trainings.isEmpty()) {
            throw new RuntimeException("Brak treningów");
        }

        try (PDDocument document = new PDDocument();  // tworzysz dokument PDF
             ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) {


            PDType0Font fontBold = PDType0Font.load(document, getClass().getResourceAsStream("/fonts/arialbd.ttf"));
            PDType0Font fontRegular = PDType0Font.load(document, getClass().getResourceAsStream("/fonts/arial.ttf"));

            PDPage page = new PDPage(); // nowa strona PDF
            document.addPage(page); //do pdfa dodajesz strone

            PDPageContentStream content = new PDPageContentStream(document, page, PDPageContentStream.AppendMode.APPEND, true, true);
            int y = 750; // Wysokosc startowa na stronie (od gory)
            int lineHeight = 20; //  Odległość między kolejnymi liniami tekstu


            for (TrainingDTO training : trainings) {

                if(y < 50){
                    content.close();
                    page = new PDPage();
                    document.addPage(page);
                    content = new PDPageContentStream(document, page, PDPageContentStream.AppendMode.APPEND, true, true);
                    y = 750;
                }

                content.beginText(); // Rozpoczynamy pisanie tekstu
                content.setFont(fontBold, 14); // Ustawiamy pogrubioną czcionkę o rozmiarze 14
                content.newLineAtOffset(50, y); // Ustawiamy pozycję startową tekstu (x=50, y)
                content.showText("Trening: " + training.date()); // Wypisujemy tekst z datą treningu
                content.endText(); // Kończymy pisanie tekstu
                y -= lineHeight; // Przesuwamy kursor w dół o wysokość jednej linii

                if(y < 50){
                    content.close();
                    page = new PDPage();
                    document.addPage(page);
                    content = new PDPageContentStream(document, page, PDPageContentStream.AppendMode.APPEND, true, true);
                    y = 750;
                }
                content.beginText();
                content.setFont(fontRegular, 12);
                content.newLineAtOffset(50, y);
                content.showText("Notatka: " + training.note() + " | Intensywność: " + training.intensityScore());
                content.endText();
                y -= lineHeight;


                // Ćwiczenia
                for (TrainingExerciseDTO ex : training.exercises()) {
                    if(y < 50){
                        content.close();
                        page = new PDPage();
                        document.addPage(page);
                        content = new PDPageContentStream(document, page, PDPageContentStream.AppendMode.APPEND, true, true);
                        y = 750;
                    }
                    content.beginText();
                    content.setFont(fontRegular, 12);
                    content.newLineAtOffset(60, y);
                    content.showText("- " + ex.exerciseDisplayName() + ": " + ex.amount() + " powt., " + ex.duration() + " min");
                    content.endText();
                    y -= lineHeight;
                }
                y -= 10;
            }


            content.beginText();
            content.setFont(fontBold, 14);
            content.newLineAtOffset(50, y);
            content.showText("Dziękujemy za korzystanie z Trainify");
            content.endText();
            y -= lineHeight;


            content.beginText();
            content.setFont(fontRegular, 18);
            content.newLineAtOffset(50,y);
            content.showText("( ͡° ͜ʖ ͡°)");
            content.endText();
            y -= lineHeight;

            content.close();

            document.save(byteArrayOutputStream);  //zapisujesz dokument
            return byteArrayOutputStream.toByteArray(); // zwracasz PDF jako tablicę bajtów

        } catch (Exception e) {
            throw new RuntimeException("Błąd przy generowaniu PDF ", e);
        }

    }
}
package com.trainify.trainifybackend.security.service;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

import java.security.Key;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

@Service
public class JwtService {

    // 🔑 Tajny klucz do podpisywania tokenów.
    // Powinien być przechowywany w application.properties i być silny (min. 256 bit, czyli 32 znaki base64).
    @Value("${application.security.jwt.secret-key}")
    private String secretKey;

    // ⏱ Czas wygaśnięcia tokena (np. 24 godziny)
    @Value("${application.security.jwt.expiration}")
    private long jwtExpiration;

    // --- Metody publiczne ---

    // 1. Ekstrakcja nazwy użytkownika (email) z tokena
    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    // 2. Generowanie tokena dla UserDetails (użytkownik)
    public String generateToken(UserDetails userDetails) {
        return generateToken(new HashMap<>(), userDetails);
    }

    // 3. Sprawdzenie, czy token jest ważny dla danego użytkownika
    public boolean isTokenValid(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername())) && !isTokenExpired(token);
    }


    // --- Metody prywatne (pomocnicze) ---

    // Ekstrakcja pojedynczej 'claims' (danych) z tokena
    private <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    // Generowanie tokena z dodatkowymi danymi ('extraClaims')
    private String generateToken(
            Map<String, Object> extraClaims,
            UserDetails userDetails
    ) {
        return Jwts
                .builder() // Rozpoczęcie budowania tokena
                .setClaims(extraClaims) // Dodatkowe claims
                .setSubject(userDetails.getUsername()) // Temat (zazwyczaj nazwa użytkownika/email)
                .setIssuedAt(new Date(System.currentTimeMillis())) // Czas utworzenia
                .setExpiration(new Date(System.currentTimeMillis() + jwtExpiration)) // Czas wygaśnięcia
                .signWith(getSignInKey(), SignatureAlgorithm.HS256) // Podpisanie kluczem SHA-256
                .compact(); // Zbudowanie i zwrócenie jako String
    }

    // Sprawdzenie, czy token wygasł
    private boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    // Ekstrakcja daty wygaśnięcia
    private Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    // Ekstrakcja wszystkich 'claims' (danych) z tokena
    private Claims extractAllClaims(String token) {
        return Jwts
                .parserBuilder() // Uruchomienie parsera
                .setSigningKey(getSignInKey()) // Użycie tajnego klucza
                .build()
                .parseClaimsJws(token) // Parsowanie tokena
                .getBody(); // Pobranie zawartości (claims)
    }

    // Pobranie tajnego klucza do podpisu
    private Key getSignInKey() {
        byte[] keyBytes = Decoders.BASE64.decode(secretKey); // Dekodowanie klucza z Base64
        return Keys.hmacShaKeyFor(keyBytes); // Zbudowanie klucza
    }
}
package com.trainify.trainifybackend.security;

import com.trainify.trainifybackend.security.service.JwtService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {  // OncePerRequestFilter — zapewnia, że filtr wykona się tylko raz na każde żądanie HTTP.

    private final JwtService jwtService;
    private final UserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(
            @NonNull HttpServletRequest request,
            @NonNull HttpServletResponse response,
            @NonNull FilterChain filterChain // Zbiór filtrów, przez które ma przejść żądanie
    ) throws ServletException, IOException {

        final String authHeader = request.getHeader("Authorization"); // Pobranie nagłówka "Authorization", to tutaj frontend przesyła token JWT
        final String jwt;
        final String userEmail;

        // 1. Sprawdzenie, czy nagłówek istnieje i zaczyna się od "Bearer "
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response); // Przekazanie do kolejnego filtra
            return;
        }

        jwt = authHeader.substring(7); // Obcina pierwsze 7 znaków ("Bearer ") i zostawia sam token JWT. Przykład:"Bearer abc.def.ghi" → "abc.def.ghi"
        userEmail = jwtService.extractUsername(jwt); // Używa mojego JwtService zeby wyciagnac email uzytkownika (Bo w tokenie zapisuje jego adres email)

        // 2. Warunek sprawdzajacy czy token faktycznie zawiera email i czy nikt jeszcze nie jest zalogowany
        if (userEmail != null && SecurityContextHolder.getContext().getAuthentication() == null) {

            // Wczytanie szczegółów użytkownika (UserDetails) z bazy na podstawie emaila użytkownika
            UserDetails userDetails = this.userDetailsService.loadUserByUsername(userEmail);


            // 3. Sprawdza czy token JWT jest ważny i prawidłowy
            //Jezeli token jest wazny i prawidlowy, tworzymy obiekt uwierzytelnienia ktory mowi "ten uzytkownik jest zalogowany"
            if (jwtService.isTokenValid(jwt, userDetails)) {

                // Tworzenie obiektu uwierzytelnienia Spring Security
                UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                        userDetails,
                        null, // JWT nie przechowuje hasła, więc null
                        userDetails.getAuthorities() // Uprawnienia (role)
                );

                // Dodanie szczegółów żądania do tokena (np. IP, sesja)
                authToken.setDetails(
                        new WebAuthenticationDetailsSource().buildDetails(request)
                );

                // 4. Ustawia w globalnym kontekście Spring Security, że ten użytkownik jest zalogowany (NAJWAŻNIEJSZA LINIA)
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }
        filterChain.doFilter(request, response); // Przekazanie do kolejnego filtra/kontrolera
    }
}
package com.trainify.trainifybackend.training.controller;


import com.trainify.trainifybackend.training.dto.TrainingDTO;
import com.trainify.trainifybackend.training.dto.TrainingPlanDTO;
import com.trainify.trainifybackend.training.dto.TrainingStatisticsDTO;
import com.trainify.trainifybackend.training.service.TrainingService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequiredArgsConstructor
public class TrainingController {

    private final TrainingService trainingService;


    @PostMapping("/training")
    public ResponseEntity<TrainingDTO> addTraining(@RequestBody @Valid TrainingDTO trainingDTO) {
        return ResponseEntity.ok(trainingService.addTraining(trainingDTO));
    }

    @PostMapping("/training/addReadyPlanToUser/{userId}")
    public ResponseEntity<TrainingDTO> addReadyPlanToUser(@RequestBody TrainingPlanDTO trainingPlanDTO, @PathVariable Long userId){
        return ResponseEntity.ok(trainingService.addReadyPlanToUser(userId, trainingPlanDTO));
    }


    @DeleteMapping("/training/{trainingId}/{userId}")
    public ResponseEntity<Void> deleteTraining(@PathVariable Long trainingId, @PathVariable Long userId) {
        trainingService.deleteTraining(trainingId, userId);
        return ResponseEntity.noContent().build();
    }

    @PutMapping("/training/{trainingId}/{userId}")
    public ResponseEntity<TrainingDTO> updateTraining(@RequestBody @Valid TrainingDTO trainingDTO, @PathVariable Long trainingId, @PathVariable Long userId) {
        return ResponseEntity.ok(trainingService.updateTraining(trainingDTO, trainingId, userId));
    }

    @GetMapping("/training/{userId}")
    public ResponseEntity<TrainingStatisticsDTO> getStatisticsForUserId(@PathVariable Long userId) {
        return ResponseEntity.ok(trainingService.getStatisticsForUserId(userId));
    }

    @GetMapping("/training/history")
    public ResponseEntity<List<TrainingDTO>> getTrainingHistory() {
        String userEmail = SecurityContextHolder.getContext().getAuthentication().getName();
        return ResponseEntity.ok(trainingService.getTrainingsForUserByEmail(userEmail));
    }


}
package com.trainify.trainifybackend.training.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import jakarta.validation.constraints.PastOrPresent;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;

public record TrainingDTO(

        Long id, // trainingId
        Long userId,

        String note,

        double intensityScore, // Wynik intensywnosci treningu 0 - 100
        String intensityScoreMessage, // Komunikat jak intensywny trening był


        @PastOrPresent LocalDate date,
        @JsonInclude(JsonInclude.Include.NON_NULL) LocalDateTime createdAt,

        List<TrainingExerciseDTO> exercises


) {
}
package com.trainify.trainifybackend.training.dto;

import com.trainify.trainifybackend.training.model.exerciseModel.ExerciseCategory;

public record TrainingExerciseDTO(

        Long id,

        ExerciseCategory exerciseCategory,
        String exerciseName,
        String exerciseDisplayName,



        int amount,
        int duration

        ) {
}
package com.trainify.trainifybackend.training.dto;

import java.util.List;

public record TrainingPlanDTO (
        String name,
        List<TrainingExerciseDTO> exercises

){}
package com.trainify.trainifybackend.training.dto;

public record TrainingStatisticsDTO(
        double averageDuration,
        double averageAmount,
        double averageIntensityScore
        //Najczestsze cwiczenie

) {
}
package com.trainify.trainifybackend.training.model.exerciseModel;

import lombok.Getter;

@Getter
public enum AbsExercise {
    PLANK("Plank"),
    PLANK_BOCZNY("Plank boczny"),
    HOLLOW_BODY_HOLD("Hollow Body Hold"),
    HOLLOW_BODY_ROCK("Hollow Body Rock"),
    L_SIT("L-sit"),
    UNOSZENIE_KOLAN_W_ZWISIE("Unoszenie kolan w zwisie"),
    UNOSZENIE_NOG_W_ZWISIE("Unoszenie nóg w zwisie"),
    TOES_TO_BAR("Toes to Bar"),
    DRAGON_FLAG("Dragon Flag"),
    V_UP("V-Up"),
    RUSKIE_SKRETY("Rosyjskie skręty"),
    MOUNTAIN_CLIMBER("Mountain Climber"),
    PLANK_KOLANO_DO_LOKCI("Plank z kolanem do łokcia"),
    WINDSHIELD_WIPERS("Windshield Wipers"),
    ROLLOUT_BZUCH("Rollout brzucha");

    private final String nazwa;

    AbsExercise(String nazwa) {
        this.nazwa = nazwa;
    }
}
package com.trainify.trainifybackend.training.model.exerciseModel;

import lombok.Getter;

@Getter
public enum ArmExercise {
    DIPY_NA_PORECZACH("Dipy na poręczach"),
    DIPY_NA_KOLKACH("Dipy na kółkach"),
    DIPY_IZOMETRYCZNE("Dipy izometryczne"),
    POMPKI_DIAMENTOWE("Pompki diamentowe"),
    POMPKI_WASKIE("Pompki wąskie"),
    L_SIT_DO_DIPOW("L-sit do dipów"),
    PODCIAGANIE_PODCHWYTEM("Podciąganie podchwytem"),
    PODCIAGANIE_NEUTRALNYM_CHWYtem("Podciąganie neutralnym chwytem"),
    PODCIAGANIE_Z_SUPINACJA("Podciąganie z supinacją"),
    NEGATYWNE_PODCIAGANIE_PODCHWYTEM("Negatywne podciąganie podchwytem"),
    POMPKI_ARCHER("Pompki archer"),
    SLOW_DIP("Slow Dip"),
    POMPKI_WASKIE_WOLNE("Pompki wąskie wolne"),
    POMPKI_PLANCHE_LEAN_RAMIONA("Pompki typu planche lean"),
    PULL_UP_EKSPL("Pull-Up Explosive");

    private final String nazwa;

    ArmExercise(String nazwa) {
        this.nazwa = nazwa;
    }
}
package com.trainify.trainifybackend.training.model.exerciseModel;

import lombok.Getter;

@Getter
public enum BackExercise {
    PODCIAGANIE_NACHWYTEM("Podciąganie nachwytem"),
    PODCIAGANIE_PODCHWYTEM("Podciąganie podchwytem"),
    PODCIAGANIE_NEUTRALNYM_CHWYTEM("Podciąganie neutralnym chwytem"),
    PODCIAGANIE_SZEROKIM_NACHWYTEM("Podciąganie szerokim nachwytem"),
    PODCIAGANIE_WASKIM_NACHWYTEM("Podciąganie wąskim nachwytem"),
    PODCIAGANIE_LUKOWE("Podciąganie łukowe"),
    PODCIAGANIE_TYPEWRITER("Podciąganie typu typewriter"),
    WIOSLOWANIE_AUSTRALIJSKIE("Wiosłowanie australijskie"),
    WIOSLOWANIE_POZIOME("Wiosłowanie poziome"),
    WIOSLOWANIE_NA_KOLKACH("Wiosłowanie na kółkach"),
    SCAPULAR_PULL_UP("Scapular Pull-Up"),
    BIRD_DOG("Bird-Dog"),
    SUPERMAN("Superman"),
    FRONT_LEVER_TUCK_HOLD("Front Lever Tuck Hold"),
    PODCIAGANIE_COMMANDO("Podciąganie commando");

    private final String nazwa;

    BackExercise(String nazwa) {
        this.nazwa= nazwa;
    }
}
package com.trainify.trainifybackend.training.model.exerciseModel;

import lombok.Getter;

@Getter
public enum ChestExercise {
    POMPKI_KLASYCZNE("Pompki klasyczne"),
    POMPKI_SKOSNE("Pompki skośne"),
    POMPKI_SZEROKIE("Pompki szerokie"),
    DIPY_NA_PORECZACH("Dipy na poręczach"),
    DIPY_NA_KOLKACH("Dipy na kółkach"),
    POMPKI_DIAMENTOWE("Pompki diamentowe"),
    POMPKI_ARCHER("Pompki archer"),
    POMPKI_Z_WYSUNIECIEM_RAK("Pompki z wysunięciem rąk"),
    POMPKI_PLANCHE_LEAN("Pompki planche lean"),
    POMPKI_TYPEWRITER("Pompki typu typewriter"),
    POMPKI_NISKI_SUPPORT("Pompki na niskim podpórze"),
    POMPKI_EKSPLODUJACE("Pompki eksplodujące"),
    POMPKI_WOLNE("Pompki wolne"),
    POMPKI_SZEROKIE_KOLKA("Pompki na szerokich kółkach"),
    DIPY_IZOMETRYCZNE("Dipy izometryczne");  // średnik po ostatniej wartości


    private final String nazwa;

    ChestExercise(String nazwa) {
        this.nazwa= nazwa;
    }

}
package com.trainify.trainifybackend.training.model.exerciseModel;

public enum ExerciseCategory {
    Klata,
    Plecy,
    Barki,
    Ramiona,
    Brzuch,
    Nogi
}
package com.trainify.trainifybackend.training.model.exerciseModel;

import lombok.Getter;

@Getter
public enum LegExercise {
    PRZYSIAD_KLASYCZNY("Przysiad klasyczny"),
    PRZYSIAD_SUMO("Przysiad sumo"),
    PRZYSIAD_BULGARSKI("Przysiad bułgarski"),
    PRZYSIAD_JEDNONOGI_PROGRESJA("Przysiad na jednej nodze – progresja"),
    WYKROK_DO_PRZODU("Wykrok do przodu"),
    WYKROK_W_TYL("Wykrok w tył"),
    WYKROK_BOCZNY("Wykrok boczny"),
    SKOK_W_MIEJSCU("Skok w miejscu"),
    SKOK_NA_JEDNEJ_NODZE("Skok na jednej nodze"),
    GLUTE_BRIDGE("Glute Bridge"),
    GLUTE_BRIDGE_JEDNA_NOGA("Glute Bridge na jednej nodze"),
    DONKEY_KICK("Donkey Kick"),
    WZNOSY_NA_PALCE("Wznosy na palce"),
    WALL_SIT("Wall Sit"),
    SKOK_W_DAL_Z_MIEJSCA("Skok w dal z miejsca");


    private final String nazwa;

    LegExercise(String nazwa) {
        this.nazwa= nazwa;
    }

}
package com.trainify.trainifybackend.training.model.exerciseModel;

import lombok.Getter;

@Getter
public enum ShoulderExercise {
    POMPKI_PIKE("Pompki pike"),
    POMPKI_PIKE_PODWYZSZENIE("Pompki pike na podwyższeniu"),
    POMPKI_DIVE_BOMBER("Pompki dive bomber"),
    POMPKI_HINDU("Pompki hindu"),
    WALL_HANDSTAND_HOLD("Wall Handstand Hold"),
    HANDSTAND_SHRUG("Handstand Shrug"),
    PLANCHE_LEAN("Planche Lean"),
    POMPKI_PLANCHE_LEAN("Pompki planche lean"),
    TUCK_FRONT_LEVER_HOLD("Tuck Front Lever Hold"),
    PLANK_DOTK_BARKU("Plank z dotknięciem barku"),
    PLANK_DO_POZYCJI_DOG("Plank do pozycji psa z głową w dół"),
    RING_SUPPORT_HOLD("Ring Support Hold"),
    WZNOSY_BARKOW_STANIE_REKACH("Wznosy barków w staniu na rękach"),
    L_SIT_DO_TUCK_PLANCHE("L-sit do tuck planche"),
    POMPKI_EKSPLODUJACE_PIKE("Pompki eksplodujące w pike");

    private final String nazwa;

    ShoulderExercise(String nazwa) {
        this.nazwa = nazwa;
    }
}
package com.trainify.trainifybackend.training.model;


import com.trainify.trainifybackend.user.model.User;
import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;

@Entity
@Table(name = "training")
@Getter
@Setter
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class Training {


    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private LocalDate date; // data treningu
    private LocalDateTime createdAt;// kiedy wpis został dodany


    private double intensityScore; // Wynik intensywnosci treningu 0 - 100
    private String intensityScoreMessage; // Komunikat jak intensywny trening był


    String note;


    @ManyToOne
    @JoinColumn(name = "user_id")
    private User userAssigned;


    @OneToMany(mappedBy = "trainingAssigned", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<TrainingExercise> exercises;


}
package com.trainify.trainifybackend.training.model;


import com.trainify.trainifybackend.training.model.exerciseModel.ExerciseCategory;
import jakarta.persistence.*;
import lombok.*;

@Builder
@Entity
@Getter
@Setter
@Table(name = "trainingExercise")
@AllArgsConstructor
@NoArgsConstructor

public class TrainingExercise {


    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Enumerated(EnumType.ORDINAL)
    private ExerciseCategory exerciseCategory; // Kategoria ćwiczenia (np. Ramiona)
    private String exerciseName;  // DIPY_NA_PORECZACH
    private String exerciseDisplayName; // Dipy na poręczach


    private int amount; // liczba powtórzeń

    private int duration; // czas w minutach cwiczenia





    @ManyToOne
    @JoinColumn(name = "training_id")
    private Training trainingAssigned;


}
package com.trainify.trainifybackend.training.repository;

import com.trainify.trainifybackend.training.model.Training;
import com.trainify.trainifybackend.training.model.TrainingExercise;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface TrainingRepository extends JpaRepository<Training, Long> {


    Optional<Training> findTrainingByIdAndUserAssigned_Id(Long trainingId, Long userId); // metoda do pobierania treningu po ID treningu i ID użytkownika

    List<Training> findAllByUserAssigned_Id(Long userId); // Pobieranie wszystkich treningów danego użytkownika

}
package com.trainify.trainifybackend.training.service;

import org.springframework.stereotype.Service;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.List;
import java.util.Random;

@Service
public class GenerateTisFeedbackService {
    private final List<String> lightFeedback = load("tisfeedback/lightFeedback.txt");
    private final List<String> goodFeedback = load("tisfeedback/goodFeedback.txt");
    private final List<String> veryGoodFeedback = load("tisfeedback/veryGoodFeedback.txt");


    private final Random random = new Random();


    public List<String> load(String path) {
        try (InputStream inputStream = getClass().getClassLoader().getResourceAsStream(path)) {
            if (inputStream == null) throw new IllegalStateException("Nie znaleziono pliku" + path);

            return new BufferedReader(new InputStreamReader(inputStream))
                    .lines()
                    .filter(line -> !line.isBlank()) // pomija puste linie
                    .toList();

        } catch (IOException e) {
            throw new RuntimeException("Błąd podczas ładowania pliku");
        }
    }

    public String generateRandomLightFeedback(){
        return  lightFeedback.get(random.nextInt(lightFeedback.size()));
    }

    public String generateRandomGoodFeedback(){
        return  goodFeedback.get(random.nextInt(goodFeedback.size()));
    }

    public String generateRandomVeryGoodFeedback(){
        return  veryGoodFeedback.get(random.nextInt(veryGoodFeedback.size()));
    }


}




package com.trainify.trainifybackend.training.service;

import com.trainify.trainifybackend.exception.TrainingForUserNotFoundException;
import com.trainify.trainifybackend.exception.UserNotFoundException;
import com.trainify.trainifybackend.training.dto.TrainingDTO;
import com.trainify.trainifybackend.training.dto.TrainingExerciseDTO;
import com.trainify.trainifybackend.training.dto.TrainingPlanDTO;
import com.trainify.trainifybackend.training.dto.TrainingStatisticsDTO;
import com.trainify.trainifybackend.training.model.Training;
import com.trainify.trainifybackend.training.model.TrainingExercise;
import com.trainify.trainifybackend.training.model.exerciseModel.*;
import com.trainify.trainifybackend.training.repository.TrainingRepository;
import com.trainify.trainifybackend.user.model.User;
import com.trainify.trainifybackend.user.repository.UserRepository;
import com.trainify.trainifybackend.user.service.UserService;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class TrainingService {


    private final TrainingRepository trainingRepository;
    private final UserRepository userRepository;
    private final UserService userService;
    private final GenerateTisFeedbackService generateTisFeedbackService;

    @Transactional
    public TrainingDTO addTraining(TrainingDTO trainingDTO) {

        User user = userService.getUserById(trainingDTO.userId())
                .orElseThrow(() -> new UserNotFoundException("Nie znaleziono użytkownika z id " + trainingDTO.userId()));
        Training training = Training.builder()
                .date(trainingDTO.date())
                .createdAt(LocalDateTime.now())
                .note(trainingDTO.note())
                .intensityScore(trainingDTO.intensityScore())
                .intensityScoreMessage(trainingDTO.intensityScoreMessage())
                .userAssigned(user)
                .build();


        //Sprawdzam, czy lista ćwiczeń w dto istnieje i sprawdzam, czy lista nie jest pusta, jeżeli się zgadza tworze ćwiczenia
        if (!CollectionUtils.isEmpty(trainingDTO.exercises())) {
            List<TrainingExercise> exercises = createExercise(trainingDTO, training);
            training.setExercises(exercises);
            calculateTiS(training);
        }


        trainingRepository.save(training);
        List<TrainingExerciseDTO> getExercise = getExercise(training);

        return new TrainingDTO(
                training.getId(),
                user.getId(),
                training.getNote(),
                training.getIntensityScore(),
                training.getIntensityScoreMessage(),
                training.getDate(),
                training.getCreatedAt(),
                getExercise
        );

    }

    @Transactional
    public TrainingDTO updateTraining(TrainingDTO trainingDTO, Long trainingId, Long userId) {
        Training existingTraining = trainingRepository.findTrainingByIdAndUserAssigned_Id(trainingId, userId)
                .orElseThrow(() -> new TrainingForUserNotFoundException(
                        "Nie znaleziono treningu o podanym ID dla tego użytkownika"
                ));


        existingTraining.setDate(trainingDTO.date()); // Najpierw zmieniasz date w istniejącym obiekcie, zanim zapiszesz go w repozytorium, to standardowa aktualizacja encji.
        existingTraining.setNote(trainingDTO.note()); // aktualizacja notatki

        //Zastępuje stare ćwiczenia nowymi, tak żeby Hibernate poprawnie usuwał te usunięte.
        List<TrainingExercise> newExercises = createExercise(trainingDTO, existingTraining);
        if (existingTraining.getExercises() == null) {
            existingTraining.setExercises(newExercises);
        } else {
            existingTraining.getExercises().clear();
            existingTraining.getExercises().addAll(newExercises);
        }

        calculateTiS(existingTraining);
        trainingRepository.save(existingTraining);

        List<TrainingExerciseDTO> getExercise = getExercise(existingTraining);

        return new TrainingDTO(
                existingTraining.getId(),

                userId,
                existingTraining.getNote(),
                existingTraining.getIntensityScore(),
                existingTraining.getIntensityScoreMessage(),
                existingTraining.getDate(),
                existingTraining.getCreatedAt(),
                getExercise

        );
    }

    public List<TrainingExercise> createExercise(TrainingDTO trainingDTO, Training training) {
        return trainingDTO.exercises().stream()
                .map(dto -> {

                    // Pobieramy nazwę ćwiczenia i jego "przyjazną" nazwę do wyświetlania
                    String name = dto.exerciseName(); // np. "DIPY_NA_PORECZACH" – nazwa w enum
                    String displayName = dto.exerciseDisplayName(); //  np. "Dipy na poręczach" – do pokazania użytkownikowi

                    /* Jeśli displayName jest puste, używamy enumów, aby dopasować techniczną nazwę do czytelnej nazwy
                    valueOf(name) zamienia String w odpowiadającą stałą enumu (np. "POMPKI_KLASYCZNE" → ChestExercise.POMPKI_KLASYCZNE)*/
                    if (displayName == null && name != null) {
                        switch (dto.exerciseCategory()) {
                            case Klata -> displayName = ChestExercise.valueOf(name).getNazwa();
                            // valueOf(name) – znajdź element enum ChestExercise o dokładnie tej nazwie (np. "POMPKI_KLASYCZNE")
                            // getNazwa() – pobierz "czytelną" nazwę ćwiczenia np. "Pompki klasyczne"
                            case Plecy -> displayName = BackExercise.valueOf(name).getNazwa();
                            case Barki -> displayName = ShoulderExercise.valueOf(name).getNazwa();
                            case Ramiona -> displayName = ArmExercise.valueOf(name).getNazwa();
                            case Brzuch -> displayName = AbsExercise.valueOf(name).getNazwa();
                            case Nogi -> displayName = LegExercise.valueOf(name).getNazwa();
                        }
                    }

                    return TrainingExercise.builder()
                            .id(dto.id())
                            .exerciseCategory(dto.exerciseCategory())
                            .exerciseName(name)
                            .exerciseDisplayName(displayName)
                            .amount(dto.amount())
                            .duration(dto.duration())
                            .trainingAssigned(training)
                            .build();
                })
                .collect(Collectors.toList());
    }


    public List<TrainingExerciseDTO> getExercise(Training training) {
        List<TrainingExercise> exercises = training.getExercises();
        if (exercises == null) {
            return Collections.emptyList();
        }
        return exercises.stream().map(
                        exercise -> new TrainingExerciseDTO(
                                exercise.getId(),
                                exercise.getExerciseCategory(),
                                exercise.getExerciseName(),
                                exercise.getExerciseDisplayName(),
                                exercise.getAmount(),
                                exercise.getDuration()
                        ))
                .collect(Collectors.toList());
    }


    public void deleteTraining(Long trainingId, Long userId) {
        Training training = trainingRepository.findTrainingByIdAndUserAssigned_Id(trainingId, userId)
                .orElseThrow(() -> new TrainingForUserNotFoundException(
                        "Nie znaleziono treningu o podanym ID dla tego użytkownika"
                ));
        trainingRepository.delete(training);

    }


    public TrainingDTO addReadyPlanToUser(Long userId, TrainingPlanDTO trainingPlanDTO) {
        User user = userService.getUserById(userId)
                .orElseThrow(() -> new UserNotFoundException("Nie znaleziono użytkownika o id " + userId));

        //Tworzymy nowy trening
        Training training = Training.builder()
                .date(LocalDate.now())
                .createdAt(LocalDateTime.now())
                .note(trainingPlanDTO.name())
                .userAssigned(user)
                .build();

        // Tworzymy listę ćwiczeń dla treningu na podstawie DTO
        List<TrainingExercise> exercises = trainingPlanDTO.exercises().stream()
                .map(dto -> {
                    String displayName = dto.exerciseDisplayName();
                    String exerciseName = dto.exerciseName();

                    if ((displayName == null || displayName.isEmpty()) && exerciseName != null) {
                        switch (dto.exerciseCategory()) {
                            case Klata -> displayName = ChestExercise.valueOf(exerciseName).getNazwa();
                            case Plecy -> displayName = BackExercise.valueOf(exerciseName).getNazwa();
                            case Barki -> displayName = ShoulderExercise.valueOf(exerciseName).getNazwa();
                            case Ramiona -> displayName = ArmExercise.valueOf(exerciseName).getNazwa();
                            case Brzuch -> displayName = AbsExercise.valueOf(exerciseName).getNazwa();
                            case Nogi -> displayName = LegExercise.valueOf(exerciseName).getNazwa();
                        }
                    }
                    // Tworzymy obiekt TrainingExercise i przypisujemy ćwiczenia z powyżej do treningu utworzonego wcześniej
                    return TrainingExercise.builder()
                            .exerciseCategory(dto.exerciseCategory())
                            .exerciseName(exerciseName)
                            .exerciseDisplayName(displayName)
                            .amount(dto.amount())
                            .duration(dto.duration())
                            .trainingAssigned(training)
                            .build();
                })
                .collect(Collectors.toList());


        training.setExercises(exercises);
        calculateTiS(training);
        trainingRepository.save(training);

        List<TrainingExerciseDTO> getExercise = getExercise(training);

        return new TrainingDTO(
                training.getId(),
                userId,
                training.getNote(),
                training.getIntensityScore(),
                training.getIntensityScoreMessage(),
                training.getDate(),
                training.getCreatedAt(),
                getExercise
        );
    }

    public TrainingStatisticsDTO getStatisticsForUserId(Long userId) {
        List<Training> trainings = trainingRepository.findAllByUserAssigned_Id(userId);

        if (trainings.isEmpty()) {
            return new TrainingStatisticsDTO(0, 0, 0);
        }


        //średnia czasu całego treningu -> sumujemy czas wszystkich ćwiczeń w treningu, potem średnia po treningach
        double averageDuration = trainings.stream()
                .mapToDouble(t -> t.getExercises().stream()
                        .mapToInt(TrainingExercise::getDuration)
                        .sum()
                )
                .average()
                .orElse(0.0);

        //średnia liczby powtórzeń -> sumujemy wszystkie ćwiczenia w treningu, potem średnia po treningach
        double averageAmount = trainings.stream()
                .mapToDouble(t -> t.getExercises().stream()
                        .mapToInt(TrainingExercise::getAmount)
                        .sum()
                )
                .average()
                .orElse(0.0);

        double averageIntensityScore = trainings.stream()
                .mapToDouble(Training::getIntensityScore)
                .average()
                .orElse(0.0);

        return new TrainingStatisticsDTO(averageDuration, averageAmount, averageIntensityScore);
    }

    public List<TrainingDTO> getTrainingsForUserByEmail(String email) {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException("Nie znaleziono użytkownika po emailu " + email));
        List<Training> trainings = trainingRepository.findAllByUserAssigned_Id(user.getId());

        return trainings.stream()
                .map(this::mapToTrainingDTO)
                .collect(Collectors.toList());
    }

    private TrainingDTO mapToTrainingDTO(Training training) {
        return new TrainingDTO(
                training.getId(),
                training.getUserAssigned().getId(),
                training.getNote(),
                training.getIntensityScore(),
                training.getIntensityScoreMessage(),
                training.getDate(),
                training.getCreatedAt(),
                getExercise(training)
        );
    }


    public void calculateTiS(Training training) {


        if (training.getExercises() == null || training.getExercises().isEmpty()) {
            training.setIntensityScore(0);
            training.setIntensityScoreMessage("Brak ćwiczeń w treningu");
            return;
        }


        int totalDuration = training.getExercises().stream()
                .mapToInt(TrainingExercise::getDuration)
                .sum();
        int totalAmount = training.getExercises().stream()
                .mapToInt(TrainingExercise::getAmount)
                .sum();

      /*  Math.min(..., 100) = maksymalnie 100, Math.max(0, ...) = minimalnie 0
          Najpierw ograniczam górną granicę, potem dolną, wynik zawsze w przedziale 0–100

         Normalizacja czasu i ilości powtórzeń do zakresu 0–1
         80 minut i 500 powtórzeń to maksymalne wartości przy pełnym wyniku*/
        double calculateDuration = Math.min(totalDuration / 60.0, 1.0);
        double calculateAmount = Math.min(totalAmount / 300.0, 1.0);

        double TiS = (calculateDuration * 0.5 + calculateAmount * 0.5) * 100;
        String feedback;

        if (TiS < 40) feedback = generateTisFeedbackService.generateRandomLightFeedback();  // Dodanie losowych zdan 50 losowych dla kazdego, uzycie random
        else if (TiS < 70) feedback = generateTisFeedbackService.generateRandomGoodFeedback();
        else feedback = generateTisFeedbackService.generateRandomVeryGoodFeedback();


        training.setIntensityScore(TiS);
        training.setIntensityScoreMessage(feedback);

    }

}
package com.trainify.trainifybackend.user.controller;


import com.trainify.trainifybackend.user.dto.UserRegisterLoginDTO;
import com.trainify.trainifybackend.user.service.UserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

@RequiredArgsConstructor
@RestController
public class UserController {

    private final UserService userService;


    @PostMapping("/register")
    public ResponseEntity<UserRegisterLoginDTO> registerUser(@RequestBody @Valid UserRegisterLoginDTO userRegisterLoginDTO) {
        return ResponseEntity.ok(userService.registerUser(userRegisterLoginDTO));
    }

    @PostMapping("/login")
    public ResponseEntity<UserRegisterLoginDTO> loginUser(@RequestBody @Valid UserRegisterLoginDTO userLogin) {
        return ResponseEntity.ok(userService.loginUser(userLogin.email(), userLogin.password()));
    }
}

package com.trainify.trainifybackend.user.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;


public record UserRegisterLoginDTO(
        Long id,
        String username,
        @NotBlank
        String password,

        @Email
        String email,

        String jwtToken

) {
}
package com.trainify.trainifybackend.user.model;

import com.trainify.trainifybackend.dailywellness.model.DailyWellness;
import com.trainify.trainifybackend.healthcore.model.UserHealthMetrics;
import com.trainify.trainifybackend.training.model.Training;
import jakarta.persistence.*;
import lombok.*;
import org.springframework.security.config.annotation.web.oauth2.client.OAuth2ClientSecurityMarker;

import java.time.LocalDateTime;
import java.util.List;

@Entity
@Table(name = "users")
@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Builder
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;


    private String username;
    private String password;
    private String email;
    private LocalDateTime createdAt;


    @OneToMany(mappedBy = "userAssigned", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Training> trainings;

    @OneToMany(mappedBy = "userAssigned")
    private List<DailyWellness> dailyWellnessHistory;


    @OneToMany(mappedBy = "userAssigned")
    private List<UserHealthMetrics> userHealthMetrics;
}
package com.trainify.trainifybackend.user.repository;

import com.trainify.trainifybackend.user.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {

    Optional<User>findByEmail(String email); // metoda do znajdowania użytkownika po nazwie użytkownika lub emailu



    boolean existsByUsername(String username); // metoda do sprawdzania czy istnieje użytkownik o danej nazwie użytkownika
    boolean existsByEmail(String email); // metoda do sprawdzania czy istnieje użytkownik o danym emailu
}
package com.trainify.trainifybackend.user.service;

import com.trainify.trainifybackend.exception.EmailAlreadyExistsException;
import com.trainify.trainifybackend.exception.UserNotFoundException;
import com.trainify.trainifybackend.exception.UsernameAlreadyExistsException;
import com.trainify.trainifybackend.exception.WrongPasswordException;
import com.trainify.trainifybackend.security.service.JwtService;
import com.trainify.trainifybackend.user.dto.UserRegisterLoginDTO;
import com.trainify.trainifybackend.user.model.User;
import com.trainify.trainifybackend.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Service
@RequiredArgsConstructor
public class UserService {


    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtService jwtService;
    private final AuthenticationManager authenticationManager;


    public UserRegisterLoginDTO registerUser(UserRegisterLoginDTO userRegisterLoginDTO) {

        if (userRepository.existsByUsername(userRegisterLoginDTO.username())) {
            throw new UsernameAlreadyExistsException("Nazwa użytkownika jest już zajęta");
        }

        if (userRepository.existsByEmail(userRegisterLoginDTO.email())) {
            throw new EmailAlreadyExistsException("Email jest już zajęty");
        }


        User user = User.builder()
                .username(userRegisterLoginDTO.username())
                .email(userRegisterLoginDTO.email())
                .password(passwordEncoder.encode(userRegisterLoginDTO.password())) // hashowanie hasła
                .createdAt(LocalDateTime.now())
                .build();
        User savedUser = userRepository.save(user);

        String jwtToken = jwtService.generateToken(
                new org.springframework.security.core.userdetails.User(
                        savedUser.getEmail(),
                        savedUser.getPassword(),
                        List.of()
                )
        );

        return new UserRegisterLoginDTO(user.getId(),savedUser.getUsername(), null, savedUser.getEmail(), jwtToken);

    }

    public UserRegisterLoginDTO loginUser(String email, String rawPassword) {
        try {
            authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(email, rawPassword)
            );
        } catch (AuthenticationException e) {
            throw new WrongPasswordException("Nieprawidłowy email lub hasło");
        }


        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException("Nie znaleziono użytkownika"));


        UserDetails userDetails = new org.springframework.security.core.userdetails.User(
                user.getEmail(),
                user.getPassword(),
                List.of()
        );
        String jwtToken = jwtService.generateToken(userDetails);

        return new UserRegisterLoginDTO(user.getId(),user.getUsername(), null, user.getEmail(), jwtToken);
    }


    public Optional<User> getUserById(Long userId) {
        return userRepository.findById(userId);
    }


}
package com.trainify.trainifybackend;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableAsync;

@EnableAsync
@SpringBootApplication
public class TrainifyBackendApplication {

	public static void main(String[] args) {
		SpringApplication.run(TrainifyBackendApplication.class, args);
	}

}
package com.trainify.trainifybackend;

import com.trainify.trainifybackend.user.service.UserService;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class TrainifyBackendApplicationTests {
	@Test
	void contextLoads() {
	}

}
