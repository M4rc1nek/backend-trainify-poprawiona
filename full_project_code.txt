package com.trainify.trainifybackend.config;

import com.trainify.trainifybackend.exception.UserNotFoundException;
import com.trainify.trainifybackend.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
@RequiredArgsConstructor
public class ApplicationConfig {

    private final UserRepository userRepository; // Wstrzykniƒôcie repozytorium u≈ºytkownik√≥w

    //Wczytywanie  u≈ºytkownika i zwracanie uzytkownika z zahashowanym haslem i rolami
    @Bean
    public UserDetailsService userDetailsService() {
        return username -> userRepository.findByEmail(username) // Spring Security u≈ºyje "username", ale u nas to jest email
                .map(user -> org.springframework.security.core.userdetails.User.builder() // Mapowanie (zamiana) naszej klasy User na UserDetails
                        .username(user.getEmail())
                        .password(user.getPassword())
                        // W prostym projekcie nie u≈ºywamy r√≥l, ale je≈õli chcesz, dodaj np. .roles("USER")
                        .build())
                .orElseThrow(() -> new UserNotFoundException("Nie znaleziono u≈ºytkownika"));
    }

    // 2. Provider uwierzytelniania, pobiera haslo od uzytkownika i prosi UserDetailsService o za≈Çadaowanie zahashowanego has≈Ça z bazy
    // A nastepnie prosi PasswordEncoder o sprawdzenie czy te dwa hasla do siebie pasuja (cos typu .matches)
    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService()); // Ustawienie serwisu do ≈Çadowania u≈ºytkownika
        authProvider.setPasswordEncoder(passwordEncoder()); // Ustawienie kodera has≈Ça
        return authProvider;
    }

    // 3. Manager uwierzytelniania (Kieruje
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception { // Uwierzytelnia uzytkownikow (np. sprawdzenie loginu, hasla)
        return config.getAuthenticationManager(); // zwraca w pe≈Çni skonfigurowany obiekt AuthenticationManager
    }

    // 4. Koder has≈Ça
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
package com.trainify.trainifybackend.config;

import com.trainify.trainifybackend.security.JwtAuthenticationFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;
import java.util.List;

@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityFilterChainConfig {

    private final JwtAuthenticationFilter jwtAuthFilter;
    private final AuthenticationProvider authenticationProvider;


    //Polaczenie z frontendem
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();

        configuration.setAllowedOrigins(List.of("http://localhost:5173"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }


    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        //W≈ÇƒÖczenie CORS i wy≈ÇƒÖczenie CSRF
        http
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .csrf(csrf -> csrf.disable())

                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/register", "/login").permitAll() //register, /login ‚Üí dostƒôp dla wszystkich (nie trzeba tokena JWT).
                        .requestMatchers("/training/**").authenticated() //training/** ‚Üí dostƒôp tylko dla zalogowanych u≈ºytkownik√≥w (czyli muszƒÖ mieƒá wa≈ºny token JWT).
                        .requestMatchers("/contact").permitAll()
                        .anyRequest().authenticated()    //anyRequest().authenticated() ‚Üí ka≈ºde inne ≈ºƒÖdanie te≈º wymaga zalogowania.
                )
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) // ‚ÄûNie tw√≥rz sesji, nie zapamiƒôtuj zalogowanego u≈ºytkownika ‚Äî wszystko opiera siƒô na tokenie JWT"
                .authenticationProvider(authenticationProvider) // Mowi Springowi jak ma sprawdzac dane
                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class); // Wstaw m√≥j filtr JWT przed tym standardowym, ≈ºeby token by≈Ç sprawdzony, zanim Spring zacznie swoje logowanie

        return http.build();
    }
}
package com.trainify.trainifybackend.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("http://localhost:5173")
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(true);
    }
}
package com.trainify.trainifybackend.contact.controller;

import com.trainify.trainifybackend.contact.dto.ContactDTO;
import com.trainify.trainifybackend.contact.service.ContactService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequiredArgsConstructor
public class ContactController {

    private final ContactService contactService;


    @PostMapping("/contact")
    public ResponseEntity<Void> sendMessage(@Valid @RequestBody ContactDTO contactDTO){
        contactService.sendContactEmail(contactDTO);
        return ResponseEntity.ok().build();
    }

}
package com.trainify.trainifybackend.contact.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

public record ContactDTO(
        @NotBlank String name,
        @NotBlank String message,
        @NotBlank String subject,
        @Email String email
) {
}
package com.trainify.trainifybackend.contact.service;

import com.trainify.trainifybackend.contact.dto.ContactDTO;
import lombok.RequiredArgsConstructor;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

@Async
@Service
@RequiredArgsConstructor
public class ContactService {

   private final JavaMailSender mailSender;

   public void sendContactEmail(ContactDTO dto){
       SimpleMailMessage message = new SimpleMailMessage();
       // Adres odbiorcy ‚Äî Tw√≥j mail administratora
       message.setTo("getrespectstudio@gmail.com");
       // Temat wiadomo≈õci
       message.setSubject(dto.subject());
       message.setReplyTo(dto.email()); // // Ustawiamy adres osoby, kt√≥ra wys≈Ça≈Ça formularz, dziƒôki temu w Gmailu klikniesz "Odpowiedz" i mail p√≥jdzie do u≈ºytkownika
       message.setText(
               "Od: " + dto.name() + " (" + dto.email() + ")\n\n" + dto.message() // Tre≈õƒá wiadomo≈õci, czyli dane wys≈Çane w formularzu
       );
       mailSender.send(message);

   }

}
package com.trainify.trainifybackend.dailywellness.controller;

import com.trainify.trainifybackend.dailywellness.dto.DailyWellnessDTO;
import com.trainify.trainifybackend.dailywellness.service.DailyWellnessService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.util.List;

@RestController
@RequiredArgsConstructor
public class DailyWellnessController {

    private final DailyWellnessService dailyWellnessService;

    @PostMapping("/daily-wellness/submit")
    public ResponseEntity<DailyWellnessDTO> submitCheck(@RequestBody @Valid DailyWellnessDTO dto) {
        String userEmail = SecurityContextHolder.getContext().getAuthentication().getName();
        return ResponseEntity.ok(dailyWellnessService.submitCheck(dto, userEmail));
    }

    @GetMapping("/daily-wellness/history")
    public ResponseEntity<List<DailyWellnessDTO>> getDailyWellnessHistory() {
        String userEmail = SecurityContextHolder.getContext().getAuthentication().getName();
        return ResponseEntity.ok(dailyWellnessService.getDailyWellnessHistory(userEmail));
    }

    @DeleteMapping("/daily-wellness/{userId}")
    public ResponseEntity<Void> deleteDailyWellness(@PathVariable Long userId, @RequestParam LocalDate date) {
        dailyWellnessService.deleteDailyWellness(userId, date);
        return ResponseEntity.noContent().build();
    }

    @PutMapping("/daily-wellness/{userId}")
    public ResponseEntity<DailyWellnessDTO> updateDailyWellness(@RequestBody @Valid DailyWellnessDTO dto, @PathVariable Long userId, @RequestParam LocalDate date) {
        return ResponseEntity.ok(dailyWellnessService.updateDailyWellness(dto, userId, date));
    }

}
package com.trainify.trainifybackend.dailywellness.dto;

import com.trainify.trainifybackend.dailywellness.model.ReadinessLevel;
import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.PastOrPresent;

import java.time.LocalDate;

public record DailyWellnessDTO(

        Long id,

        @PastOrPresent LocalDate date,


        @Min(0) @Max(24) double hoursSlept,
        @Min(1) @Max(10) int energyLevel,
        @Min(1) @Max(10) int musclePain,
        @Min(1) @Max(10) int mood,
        @Min(1) @Max(10) int motivation,

        int readinessScore,
        ReadinessLevel readinessLevel,
        String recommendation
) {
}
package com.trainify.trainifybackend.dailywellness.model;


import com.trainify.trainifybackend.user.model.User;
import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDate;

@Builder
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Entity
public class DailyWellness {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private LocalDate date;

    private double hoursSlept;
    private int energyLevel;
    private int musclePain;
    private int mood;
    private int motivation;

    private int readinessScore; // Wynik oceny gotowo≈õci u≈ºytkownika w skali 0-100, wyliczany z 5 parametr√≥w.
    private ReadinessLevel readinessLevel; // Poziom gotowo≈õci: "WYSOKI", "≈öREDNI" lub "NISKI".
    private String recommendation; // Kr√≥tka rekomendacja treningowa na podstawie wyniku.




    @ManyToOne
    @JoinColumn(name = "user_id")
    private User userAssigned;

}
package com.trainify.trainifybackend.dailywellness.model;

public enum ReadinessLevel {
    Wysoki,
    ≈öredni,
    Niski

}
package com.trainify.trainifybackend.dailywellness.repository;

import com.trainify.trainifybackend.dailywellness.model.DailyWellness;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

public interface DailyWellnessRepository extends JpaRepository<DailyWellness, Long> {



    // Pobiera pojedynczy wpis DailyWellness dla konkretnego u≈ºytkownika (userId) w okre≈õlonym dniu (date).
    // Zwraca Optional, bo wpis mo≈ºe istnieƒá lub nie.
    @Query("SELECT d FROM DailyWellness d WHERE d.userAssigned.id = :userId AND d.date = :date")
    Optional<DailyWellness> findByUserAssigned_IdAndDate(@Param("userId") Long userId, @Param("date") LocalDate date);



    // Pobiera wszystkie wpisy DailyWellness dla konkretnego u≈ºytkownika (userId)
    // i zwraca je posortowane od najnowszego do najstarszego wed≈Çug daty.
    @Query("SELECT d FROM DailyWellness d WHERE d.userAssigned.id = :userId ORDER BY d.date DESC")
    List<DailyWellness> findAllByUserAssigned_IdOrderByDateDesc(@Param("userId") Long userId);


}
package com.trainify.trainifybackend.dailywellness.service;


import com.trainify.trainifybackend.dailywellness.dto.DailyWellnessDTO;
import com.trainify.trainifybackend.dailywellness.model.DailyWellness;
import com.trainify.trainifybackend.dailywellness.model.ReadinessLevel;
import com.trainify.trainifybackend.dailywellness.repository.DailyWellnessRepository;
import com.trainify.trainifybackend.exception.DailyWellnessAlreadySubmittedException;
import com.trainify.trainifybackend.exception.DailyWellnessForUserNotFoundException;
import com.trainify.trainifybackend.exception.UserNotFoundException;
import com.trainify.trainifybackend.user.model.User;
import com.trainify.trainifybackend.user.repository.UserRepository;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.util.List;

@Service
@RequiredArgsConstructor
public class DailyWellnessService {

    private final DailyWellnessRepository dailyWellnessRepository;
    private final UserRepository userRepository;

    @Transactional
    public DailyWellnessDTO submitCheck(DailyWellnessDTO dto, String email) {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException("Nie znaleziono u≈ºytkownika"));


        dailyWellnessRepository.findByUserAssigned_IdAndDate(user.getId(), LocalDate.now())
                .ifPresent(w -> {
                    throw new DailyWellnessAlreadySubmittedException("Dzisiaj formularz zosta≈Ç ju≈º wype≈Çniony");
                });


        int readinessScore = calculateReadiness(dto);
        ReadinessLevel readinessLevel = determineReadinessLevel(readinessScore);
        String recommendation = generateRecommendation(readinessLevel);


        DailyWellness dailyWellness = DailyWellness.builder()
                .date(LocalDate.now()) //LocalDate.now() zamiast dto.date() -> dlatego aby data by≈Ça pobierana z teraz, ≈ºeby u≈ºytkownik nie m√≥g≈Ç wpisaƒá np. date jutrzejszƒÖ
                .hoursSlept(dto.hoursSlept())
                .energyLevel(dto.energyLevel())
                .musclePain(dto.musclePain())
                .mood(dto.mood())
                .motivation(dto.motivation())
                .readinessScore(readinessScore)
                .readinessLevel(readinessLevel)
                .recommendation(recommendation)
                .userAssigned(user)
                .build();

        dailyWellnessRepository.save(dailyWellness);

        return new DailyWellnessDTO(
                dailyWellness.getId(),
                dailyWellness.getDate(),
                dailyWellness.getHoursSlept(),
                dailyWellness.getEnergyLevel(),
                dailyWellness.getMusclePain(),
                dailyWellness.getMood(),
                dailyWellness.getMotivation(),
                dailyWellness.getReadinessScore(),
                dailyWellness.getReadinessLevel(),
                dailyWellness.getRecommendation()
        );
    }

    public List<DailyWellnessDTO> getDailyWellnessHistory(String email) {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException("Nie znaleziono u≈ºytkownika"));
        List<DailyWellness> history = dailyWellnessRepository.findAllByUserAssigned_IdOrderByDateDesc(user.getId());

        return history.stream()
                .map(d -> new DailyWellnessDTO(
                        d.getId(),
                        d.getDate(),
                        d.getHoursSlept(),
                        d.getEnergyLevel(),
                        d.getMusclePain(),
                        d.getMood(),
                        d.getMotivation(),
                        d.getReadinessScore(),
                        d.getReadinessLevel(),
                        d.getRecommendation()
                ))
                .toList();
    }

    @Transactional
    public DailyWellnessDTO updateDailyWellness(DailyWellnessDTO dto, Long userId, LocalDate date) {
       DailyWellness existing = dailyWellnessRepository.findByUserAssigned_IdAndDate(userId, date)
                .orElseThrow(() -> new DailyWellnessForUserNotFoundException("Nie znaleziono DailyWellness dla u≈ºytkownika o ID: " + userId + " w dniu " + date));

        int readinessScore = calculateReadiness(dto);
        ReadinessLevel readinessLevel = determineReadinessLevel(readinessScore);
        String recommendation = generateRecommendation(readinessLevel);


        DailyWellness updatedDailyWellness = DailyWellness.builder()
                .id(existing.getId())
                .userAssigned(existing.getUserAssigned())
                .date(dto.date())
                .hoursSlept(dto.hoursSlept())
                .energyLevel(dto.energyLevel())
                .musclePain(dto.musclePain())
                .mood(dto.mood())
                .motivation(dto.motivation())
                .readinessScore(readinessScore)
                .readinessLevel(readinessLevel)
                .recommendation(recommendation)
                .build();


        DailyWellness saved =  dailyWellnessRepository.save(updatedDailyWellness);


        return new DailyWellnessDTO(
                saved.getId(),
                saved.getDate(),
                saved.getHoursSlept(),
                saved.getEnergyLevel(),
                saved.getMusclePain(),
                saved.getMood(),
                saved.getMotivation(),
                saved.getReadinessScore(),
                saved.getReadinessLevel(),
                saved.getRecommendation()
        );
    }


    public void deleteDailyWellness(Long userId, LocalDate date) {
        DailyWellness dailyWellness = dailyWellnessRepository.findByUserAssigned_IdAndDate(userId, date)
                .orElseThrow(() -> new DailyWellnessForUserNotFoundException("Nie znaleziono DailyWellness dla u≈ºytkownika o ID: " + userId + " w dniu " + date));
        dailyWellnessRepository.delete(dailyWellness);
    }


    private int calculateReadiness(DailyWellnessDTO dto) {

        double sleepPoints;

        if (dto.hoursSlept() >= 8) sleepPoints = 30;
        else if (dto.hoursSlept() >= 7) sleepPoints = 25;
        else if (dto.hoursSlept() >= 6) sleepPoints = 15;
        else sleepPoints = 5;

        double energyPoints = (dto.energyLevel() / 10.0) * 25;
        double musclePainPoints = ((10 - dto.musclePain()) / 10.0) * 25;
        double moodPoints = (dto.mood() / 10.0) * 15;
        double motivationPoints = (dto.motivation() / 10.0) * 10;


        return (int) Math.round(sleepPoints + energyPoints + musclePainPoints + moodPoints + motivationPoints);

    }

    private ReadinessLevel determineReadinessLevel(int score) {
        if (score >= 70) return ReadinessLevel.Wysoki;
        else if (score >= 49) return ReadinessLevel.≈öredni;
        else return ReadinessLevel.Niski;
    }

    private String generateRecommendation(ReadinessLevel readinessLevel) {
        return switch (readinessLevel) {
            case Wysoki -> "Mo≈ºesz trenowaƒá ciƒô≈ºko";
            case ≈öredni -> "Trenuj ostro≈ºnie, s≈Çuchaj cia≈Ça";
            default -> "Cia≈Ço potrzebuje regeneracji, nie trenuj";
        };

    }

}
package com.trainify.trainifybackend.exception;

public class DailyWellnessAlreadySubmittedException extends RuntimeException {
    public DailyWellnessAlreadySubmittedException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.exception;

public class DailyWellnessForUserNotFoundException extends RuntimeException {
    public DailyWellnessForUserNotFoundException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.exception;

public class EmailAlreadyExistsException extends RuntimeException {
    public EmailAlreadyExistsException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.exception;

public record ErrorResponseDTO(
        int status,      // kod HTTP (np. 400, 404, 500)
        String error,    // kr√≥tki opis b≈Çƒôdu (np. "Bad Request")
        String message,  // szczeg√≥≈Çowy komunikat (np. "Email jest ju≈º zajƒôty")
        String path,     // endpoint kt√≥ry wywo≈Ça≈Ç blƒÖd np ("/register")
        long timestamp   // czas w milisekundach od 01.01.1970 (Unix epoch), kiedy wyjƒÖtek wystƒÖpi≈Ç.,
        // Przyk≈Çad: 1734500000000 ‚Üí u≈Çatwia debugowanie i ≈õledzenie w logach
) {

    // Konstruktor u≈ÇatwiajƒÖcy ustawienie timestamp automatycznie
    public ErrorResponseDTO(int status, String error, String message, String path){
        this(status,error,message,path, System.currentTimeMillis());
    }
}
package com.trainify.trainifybackend.exception;


import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.context.request.WebRequest;

@RestControllerAdvice // -> Dzia≈Ça globalnie na wszystkie kontrolery, zwraca JSON
public class GlobalExceptionHandler {


    /*
           CONFLICT (409) ‚Üí konflikt danych (np. email ju≈º istnieje)
           NOT_FOUND (404) ‚Üí brak danych (np. u≈ºytkownik nie istnieje)
           BAD_REQUEST (400) ‚Üí b≈Çƒôdne dane wej≈õciowe (np. niepoprawny format)
           UNAUTHORIZED (401) ‚Üí nieprawid≈Çowe logowanie lub brak autoryzacji
           UNPROCESSABLE_ENTITY (422) ->  dane sƒÖ poprawne, ale operacja nie mo≈ºe zostaƒá wykonana z powod√≥w biznesowych (brakuje czego≈õ wa≈ºnego)
                          (np. pr√≥ba obliczenia TDEE bez wcze≈õniejszego obliczenia BMR)

    webRequest.getDescription(false) - Pobiera opis ≈ºƒÖdania path, np.  /register lub /login
    Je≈õli dasz true, wynik zawiera≈Çby te≈º informacje o kliencie (np. IP, host)
     */

    @ExceptionHandler({EmailAlreadyExistsException.class, UsernameAlreadyExistsException.class, DailyWellnessAlreadySubmittedException.class})
    public ResponseEntity<ErrorResponseDTO> handleConflictExceptions(RuntimeException exception, WebRequest webRequest) {
        ErrorResponseDTO body = new ErrorResponseDTO(
                HttpStatus.CONFLICT.value(),
                HttpStatus.CONFLICT.getReasonPhrase(),
                exception.getMessage(),
                webRequest.getDescription(false).replace("uri=", "")
        );
        return new ResponseEntity<>(body, HttpStatus.CONFLICT);
    }


    @ExceptionHandler({TrainingForUserNotFoundException.class, UserNotFoundException.class, DailyWellnessForUserNotFoundException.class, UserHealthMetricsNotFoundException.class})
    public ResponseEntity<ErrorResponseDTO> handleNotFoundExceptions(RuntimeException exception, WebRequest webRequest) {
        ErrorResponseDTO body = new ErrorResponseDTO(
                HttpStatus.NOT_FOUND.value(),
                HttpStatus.NOT_FOUND.getReasonPhrase(),
                exception.getMessage(),
                webRequest.getDescription(false).replace("uri=", "")
        );
        return new ResponseEntity<>(body, HttpStatus.NOT_FOUND);
    }


    @ExceptionHandler(WrongPasswordException.class)
    public ResponseEntity<ErrorResponseDTO> handleWrongPassword(WrongPasswordException exception, WebRequest webRequest) {
        ErrorResponseDTO body = new ErrorResponseDTO(
                HttpStatus.UNAUTHORIZED.value(),
                HttpStatus.UNAUTHORIZED.getReasonPhrase(),
                exception.getMessage(),
                webRequest.getDescription(false).replace("uri=", "")
        );
        return new ResponseEntity<>(body, HttpStatus.UNAUTHORIZED);
    }


    @ExceptionHandler(InvalidEnumValueException.class)
    public ResponseEntity<ErrorResponseDTO> handleInvalidEnumValue(InvalidEnumValueException exception, WebRequest webRequest) {
        ErrorResponseDTO body = new ErrorResponseDTO(
                HttpStatus.BAD_REQUEST.value(),
                HttpStatus.BAD_REQUEST.getReasonPhrase(),
                exception.getMessage(),
                webRequest.getDescription(false).replace("uri=", "")
        );
        return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);
    }


    @ExceptionHandler(MissingRequirementException.class)
    public ResponseEntity<ErrorResponseDTO> handleMissingRequirement(MissingRequirementException exception, WebRequest webRequest){
        ErrorResponseDTO body = new ErrorResponseDTO(
                HttpStatus.UNPROCESSABLE_ENTITY.value(),
                HttpStatus.UNPROCESSABLE_ENTITY.getReasonPhrase(),
                exception.getMessage(),
                webRequest.getDescription(false).replace("uri=", "")
        );
        return new ResponseEntity<>(body, HttpStatus.UNPROCESSABLE_ENTITY);
    }



    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponseDTO> handleAll(Exception exception, WebRequest webRequest) {
        ErrorResponseDTO body = new ErrorResponseDTO(
                HttpStatus.INTERNAL_SERVER_ERROR.value(),
                HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase(),
                "WystƒÖpi≈Ç nieoczekiwany b≈ÇƒÖd. Skontaktuj siƒô z administratorem.",
                webRequest.getDescription(false).replace("uri=", "")
        );
        return new ResponseEntity<>(body, HttpStatus.INTERNAL_SERVER_ERROR);
    }


}
package com.trainify.trainifybackend.exception;

public class InvalidEnumValueException extends RuntimeException {
    public InvalidEnumValueException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.exception;

public class MissingRequirementException extends RuntimeException {
    public MissingRequirementException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.exception;

public class TrainingForUserNotFoundException extends RuntimeException {
    public TrainingForUserNotFoundException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.exception;

public class UserHealthMetricsNotFoundException extends RuntimeException {
    public UserHealthMetricsNotFoundException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.exception;

public class UsernameAlreadyExistsException extends RuntimeException {
    public UsernameAlreadyExistsException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.exception;

public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.exception;

public class WrongPasswordException extends RuntimeException {
    public WrongPasswordException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.healthcore.controller;


import com.trainify.trainifybackend.healthcore.dto.UserHealthMetricsDTO;
import com.trainify.trainifybackend.healthcore.model.UserHealthMetrics;
import com.trainify.trainifybackend.healthcore.service.HealthCalculatorService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequiredArgsConstructor
public class UserHealthMetricsController {

    private final HealthCalculatorService healthCalculatorService;

    @PostMapping("/addBMI/{userId}")
    public ResponseEntity<UserHealthMetricsDTO> addBMI(@RequestBody @Valid UserHealthMetricsDTO dto, @PathVariable Long userId) {
        UserHealthMetrics metrics = healthCalculatorService.buildBMI(dto, userId);
        return ResponseEntity.ok(healthCalculatorService.mapToDTO(metrics));
    }


    @PostMapping("/addBMR/{userId}")
    public ResponseEntity<UserHealthMetricsDTO> addBMR(@RequestBody @Valid UserHealthMetricsDTO dto, @PathVariable Long userId) {
        UserHealthMetrics metrics = healthCalculatorService.buildBMR(dto, userId);
        return ResponseEntity.ok(healthCalculatorService.mapToDTO(metrics));
    }


    @PostMapping("/addTDEE/{userId}")
    public ResponseEntity<UserHealthMetricsDTO> addTDEE(@RequestBody @Valid UserHealthMetricsDTO dto, @PathVariable Long userId){
        UserHealthMetrics metrics = healthCalculatorService.buildTDEE(dto, userId);
        return ResponseEntity.ok(healthCalculatorService.mapToDTO(metrics));
    }

    @GetMapping("/getBMI/{userId}")
    public ResponseEntity<Double> getBMI(@PathVariable Long userId) {
        return ResponseEntity.ok(healthCalculatorService.getBMI(userId));
    }


    @GetMapping("/getBMR/{userId}")
    public ResponseEntity<Double> getBMR(@PathVariable Long userId) {
        return ResponseEntity.ok(healthCalculatorService.getBMR(userId));
    }


    @GetMapping("/getTDEE/{userId}")
    public ResponseEntity<Double> getTDEE(@PathVariable Long userId) {
        return ResponseEntity.ok(healthCalculatorService.getTDEE(userId));
    }


}

package com.trainify.trainifybackend.healthcore.dto;

public record MetricsDTO (
        double BMI,
        double BMR,
        double TDEE
){

}
package com.trainify.trainifybackend.healthcore.dto;

import com.trainify.trainifybackend.healthcore.model.ActivityLevel;
import com.trainify.trainifybackend.healthcore.model.BmiFeedback;
import com.trainify.trainifybackend.healthcore.model.GenderType;
import jakarta.validation.constraints.DecimalMax;
import jakarta.validation.constraints.DecimalMin;

public record UserHealthMetricsDTO(

        Long id,


        ActivityLevel activityLevel,
        GenderType genderType,

        int age,
        @DecimalMin("1.0") @DecimalMax("250.0") double height, // cm
        @DecimalMin("30.0") @DecimalMax("300.0") double weight, // kg

        double BMI,
        double BMR,
        double TDEE,
        BmiFeedback bmiFeedback

) {
}
package com.trainify.trainifybackend.healthcore.model;

public enum ActivityLevel {
    Brak,
    Niski,
    Umiarkowany,
    Wysoki,
    Ekstremalny,
}
package com.trainify.trainifybackend.healthcore.model;

public enum BmiFeedback {
    niedowaga,
    prawid≈Çowa,
    nadwaga,
    oty≈Ço≈õƒá
}
package com.trainify.trainifybackend.healthcore.model;

public enum GenderType {
    Mƒô≈ºczyzna,
    Kobieta
}
package com.trainify.trainifybackend.healthcore.model;

import com.trainify.trainifybackend.user.model.User;
import jakarta.persistence.*;
import lombok.*;

@AllArgsConstructor
@NoArgsConstructor
@Entity
@Builder
@Getter
@Setter
public class UserHealthMetrics {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private int age;

    private double height; // metry
    private double weight;

    private  GenderType genderType;

    @Enumerated(EnumType.STRING)
    private ActivityLevel activityLevel;

    private double BMI;
    private double BMR;
    private double TDEE;

    private BmiFeedback bmiFeedback;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User userAssigned;


}
package com.trainify.trainifybackend.healthcore.repository;

import com.trainify.trainifybackend.healthcore.model.UserHealthMetrics;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface HealthCoreRepository extends JpaRepository<UserHealthMetrics, Long> {

    Optional<UserHealthMetrics> findTopByUserAssigned_IdOrderByIdDesc(Long userId);
}
package com.trainify.trainifybackend.healthcore.service;

import com.trainify.trainifybackend.exception.InvalidEnumValueException;
import com.trainify.trainifybackend.exception.MissingRequirementException;
import com.trainify.trainifybackend.exception.UserHealthMetricsNotFoundException;
import com.trainify.trainifybackend.exception.UserNotFoundException;
import com.trainify.trainifybackend.healthcore.dto.UserHealthMetricsDTO;
import com.trainify.trainifybackend.healthcore.model.ActivityLevel;
import com.trainify.trainifybackend.healthcore.model.BmiFeedback;
import com.trainify.trainifybackend.healthcore.model.GenderType;
import com.trainify.trainifybackend.healthcore.model.UserHealthMetrics;
import com.trainify.trainifybackend.healthcore.repository.HealthCoreRepository;
import com.trainify.trainifybackend.user.model.User;
import com.trainify.trainifybackend.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class HealthCalculatorService {

    private final UserRepository userRepository;
    private final HealthCoreRepository healthCoreRepository;


    public User getUserOrThrow(Long userId) {
        return userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("Nie znaleziono u≈ºytkownika o id " + userId));
    }

    public UserHealthMetrics buildMetrics(Long userId) {
        //Szukasz ostatnich metryk u≈ºytkownika (BMI, BMR, TDEE), je≈õli sƒÖ to je zwracasz, je≈õli nie ma idzie przechodzisz do .orElseGet
        return healthCoreRepository.findTopByUserAssigned_IdOrderByIdDesc(userId)
                .orElseGet(() -> { //Tworzysz og√≥lny szkielet metryk, kt√≥ry przypisujesz do u≈ºytkownika
                    User user = getUserOrThrow(userId);
                    return UserHealthMetrics.builder()
                            .userAssigned(user)
                            .build();
                }); // Dziƒôki szkieletowi w innych metodach wystarczy tylko ustawiƒá brakujƒÖce warto≈õci, zamiast zawsze tworzyƒá nowy obiekt.

        //Zamiast zawsze tworzyƒá nowe metryki, orElseGet zostanie wywo≈Çane tylko wtedy, gdy nie znajdziemy istniejƒÖcych metryk.


    }

    public UserHealthMetrics buildBMI(UserHealthMetricsDTO dto, Long userId) {
        UserHealthMetrics userHealthMetrics = buildMetrics(userId);

        userHealthMetrics.setHeight(dto.height());
        userHealthMetrics.setWeight(dto.weight());
        calculateBMI(userHealthMetrics);

        healthCoreRepository.save(userHealthMetrics);

        return userHealthMetrics;
    }

    public UserHealthMetrics buildBMR(UserHealthMetricsDTO dto, Long userId) {
        UserHealthMetrics userHealthMetrics = buildMetrics(userId);

        userHealthMetrics.setHeight(dto.height());
        userHealthMetrics.setWeight(dto.weight());
        userHealthMetrics.setAge(dto.age());
        userHealthMetrics.setGenderType(dto.genderType());

        calculateBMR(userHealthMetrics);
        healthCoreRepository.save(userHealthMetrics);

        return userHealthMetrics;
    }

    public UserHealthMetrics buildTDEE(UserHealthMetricsDTO dto, Long userId) {
        UserHealthMetrics userHealthMetrics = buildMetrics(userId);

        if (userHealthMetrics.getBMR() == 0.0) {
            throw new MissingRequirementException("Przed obliczeniem TDEE musisz najpierw obliczyƒá BMR");
        }
        userHealthMetrics.setActivityLevel(dto.activityLevel());

        if (userHealthMetrics.getActivityLevel() == null) {
            throw new MissingRequirementException("ActivityLevel nie mo≈ºe byƒá puste przy liczeniu TDEE");
        }
        calculateTDEE(userHealthMetrics);
        healthCoreRepository.save(userHealthMetrics);

        return userHealthMetrics;
    }


    public UserHealthMetricsDTO mapToDTO(UserHealthMetrics metrics) {
        return new UserHealthMetricsDTO(
                metrics.getId(),
                metrics.getActivityLevel(),
                metrics.getGenderType(),
                metrics.getAge(),
                metrics.getHeight(),
                metrics.getWeight(),
                metrics.getBMI(),
                metrics.getBMR(),
                metrics.getTDEE(),
                metrics.getBmiFeedback()
        );
    }


    public UserHealthMetrics getMetricsOrThrow(Long userId) {
        return healthCoreRepository.findTopByUserAssigned_IdOrderByIdDesc(userId)
                .orElseThrow(() -> new UserHealthMetricsNotFoundException("Brak zapisanych metryk zdrowotnych dla u≈ºytkownika o id: " + userId));
    }

    public double getBMI(Long userId) {
        return getMetricsOrThrow(userId).getBMI();
    }

    public double getBMR(Long userId) {
        return getMetricsOrThrow(userId).getBMR();
    }

    public double getTDEE(Long userId) {
        return getMetricsOrThrow(userId).getTDEE();
    }


    private void calculateBMI(UserHealthMetrics userHealthMetrics) {
        double heightInMeters = userHealthMetrics.getHeight() / 100.0;
        double BMI = userHealthMetrics.getWeight() / (heightInMeters * heightInMeters);

        BmiFeedback feedback;

        if (BMI < 18.5) feedback = BmiFeedback.niedowaga;
        else if (BMI <= 24.9) feedback = BmiFeedback.prawid≈Çowa;
        else if (BMI <= 29.9) feedback = BmiFeedback.nadwaga;
        else feedback = BmiFeedback.oty≈Ço≈õƒá;


        userHealthMetrics.setBMI(BMI);
        userHealthMetrics.setBmiFeedback(feedback);
    }


    private void calculateBMR(UserHealthMetrics userHealthMetrics) {

        GenderType genderType = userHealthMetrics.getGenderType();
        double BMR;

        switch (genderType) {
            case Mƒô≈ºczyzna ->
                    BMR = 10 * userHealthMetrics.getWeight() + 6.25 * userHealthMetrics.getHeight() - 5 * userHealthMetrics.getAge() + 5;
            case Kobieta ->
                    BMR = 10 * userHealthMetrics.getWeight() + 6.25 * userHealthMetrics.getHeight() - 5 * userHealthMetrics.getAge() - 161;
            default -> throw new InvalidEnumValueException("Nie ma takiej p≈Çci:  " + genderType);
        }

        userHealthMetrics.setBMR(BMR);

    }

    private void calculateTDEE(UserHealthMetrics userHealthMetrics) {

        ActivityLevel activityLevel = userHealthMetrics.getActivityLevel();
        double PAL; // to samo co activityLevel ale warto≈õci nie enum (Physical Activity Level)

        switch (activityLevel) {
            case Brak -> PAL = 1.2;
            case Niski -> PAL = 1.375;
            case Umiarkowany -> PAL = 1.55;
            case Wysoki -> PAL = 1.7;
            case Ekstremalny -> PAL = 1.9;
            default -> throw new InvalidEnumValueException("Nie ma takiej aktywno≈õci:  " + activityLevel);
        }

        double TDEE = userHealthMetrics.getBMR() * PAL;

        userHealthMetrics.setTDEE(TDEE);


    }


}
package com.trainify.trainifybackend.security.service;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

import java.security.Key;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

@Service
public class JwtService {

    // üîë Tajny klucz do podpisywania token√≥w.
    // Powinien byƒá przechowywany w application.properties i byƒá silny (min. 256 bit, czyli 32 znaki base64).
    @Value("${application.security.jwt.secret-key}")
    private String secretKey;

    // ‚è± Czas wyga≈õniƒôcia tokena (np. 24 godziny)
    @Value("${application.security.jwt.expiration}")
    private long jwtExpiration;

    // --- Metody publiczne ---

    // 1. Ekstrakcja nazwy u≈ºytkownika (email) z tokena
    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    // 2. Generowanie tokena dla UserDetails (u≈ºytkownik)
    public String generateToken(UserDetails userDetails) {
        return generateToken(new HashMap<>(), userDetails);
    }

    // 3. Sprawdzenie, czy token jest wa≈ºny dla danego u≈ºytkownika
    public boolean isTokenValid(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername())) && !isTokenExpired(token);
    }


    // --- Metody prywatne (pomocnicze) ---

    // Ekstrakcja pojedynczej 'claims' (danych) z tokena
    private <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    // Generowanie tokena z dodatkowymi danymi ('extraClaims')
    private String generateToken(
            Map<String, Object> extraClaims,
            UserDetails userDetails
    ) {
        return Jwts
                .builder() // Rozpoczƒôcie budowania tokena
                .setClaims(extraClaims) // Dodatkowe claims
                .setSubject(userDetails.getUsername()) // Temat (zazwyczaj nazwa u≈ºytkownika/email)
                .setIssuedAt(new Date(System.currentTimeMillis())) // Czas utworzenia
                .setExpiration(new Date(System.currentTimeMillis() + jwtExpiration)) // Czas wyga≈õniƒôcia
                .signWith(getSignInKey(), SignatureAlgorithm.HS256) // Podpisanie kluczem SHA-256
                .compact(); // Zbudowanie i zwr√≥cenie jako String
    }

    // Sprawdzenie, czy token wygas≈Ç
    private boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    // Ekstrakcja daty wyga≈õniƒôcia
    private Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    // Ekstrakcja wszystkich 'claims' (danych) z tokena
    private Claims extractAllClaims(String token) {
        return Jwts
                .parserBuilder() // Uruchomienie parsera
                .setSigningKey(getSignInKey()) // U≈ºycie tajnego klucza
                .build()
                .parseClaimsJws(token) // Parsowanie tokena
                .getBody(); // Pobranie zawarto≈õci (claims)
    }

    // Pobranie tajnego klucza do podpisu
    private Key getSignInKey() {
        byte[] keyBytes = Decoders.BASE64.decode(secretKey); // Dekodowanie klucza z Base64
        return Keys.hmacShaKeyFor(keyBytes); // Zbudowanie klucza
    }
}
package com.trainify.trainifybackend.security;

import com.trainify.trainifybackend.security.service.JwtService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {  // OncePerRequestFilter ‚Äî zapewnia, ≈ºe filtr wykona siƒô tylko raz na ka≈ºde ≈ºƒÖdanie HTTP.

    private final JwtService jwtService;
    private final UserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(
            @NonNull HttpServletRequest request,
            @NonNull HttpServletResponse response,
            @NonNull FilterChain filterChain // Zbi√≥r filtr√≥w, przez kt√≥re ma przej≈õƒá ≈ºƒÖdanie
    ) throws ServletException, IOException {

        final String authHeader = request.getHeader("Authorization"); // Pobranie nag≈Ç√≥wka "Authorization", to tutaj frontend przesy≈Ça token JWT
        final String jwt;
        final String userEmail;

        // 1. Sprawdzenie, czy nag≈Ç√≥wek istnieje i zaczyna siƒô od "Bearer "
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response); // Przekazanie do kolejnego filtra
            return;
        }

        jwt = authHeader.substring(7); // Obcina pierwsze 7 znak√≥w ("Bearer ") i zostawia sam token JWT. Przyk≈Çad:"Bearer abc.def.ghi" ‚Üí "abc.def.ghi"
        userEmail = jwtService.extractUsername(jwt); // U≈ºywa mojego JwtService zeby wyciagnac email uzytkownika (Bo w tokenie zapisuje jego adres email)

        // 2. Warunek sprawdzajacy czy token faktycznie zawiera email i czy nikt jeszcze nie jest zalogowany
        if (userEmail != null && SecurityContextHolder.getContext().getAuthentication() == null) {

            // Wczytanie szczeg√≥≈Ç√≥w u≈ºytkownika (UserDetails) z bazy na podstawie emaila u≈ºytkownika
            UserDetails userDetails = this.userDetailsService.loadUserByUsername(userEmail);


            // 3. Sprawdza czy token JWT jest wa≈ºny i prawid≈Çowy
            //Jezeli token jest wazny i prawidlowy, tworzymy obiekt uwierzytelnienia ktory mowi "ten uzytkownik jest zalogowany"
            if (jwtService.isTokenValid(jwt, userDetails)) {

                // Tworzenie obiektu uwierzytelnienia Spring Security
                UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                        userDetails,
                        null, // JWT nie przechowuje has≈Ça, wiƒôc null
                        userDetails.getAuthorities() // Uprawnienia (role)
                );

                // Dodanie szczeg√≥≈Ç√≥w ≈ºƒÖdania do tokena (np. IP, sesja)
                authToken.setDetails(
                        new WebAuthenticationDetailsSource().buildDetails(request)
                );

                // 4. Ustawia w globalnym kontek≈õcie Spring Security, ≈ºe ten u≈ºytkownik jest zalogowany (NAJWA≈ªNIEJSZA LINIA)
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }
        filterChain.doFilter(request, response); // Przekazanie do kolejnego filtra/kontrolera
    }
}
package com.trainify.trainifybackend.training.controller;


import com.trainify.trainifybackend.training.dto.TrainingDTO;
import com.trainify.trainifybackend.training.dto.TrainingPlanDTO;
import com.trainify.trainifybackend.training.dto.TrainingStatisticsDTO;
import com.trainify.trainifybackend.training.service.TrainingService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequiredArgsConstructor
public class TrainingController {

    private final TrainingService trainingService;


    @PostMapping("/training")
    public ResponseEntity<TrainingDTO> addTraining(@RequestBody @Valid TrainingDTO trainingDTO) {
        return ResponseEntity.ok(trainingService.addTraining(trainingDTO));
    }

    @PostMapping("/training/addReadyPlanToUser/{userId}")
    public ResponseEntity<TrainingDTO> addReadyPlanToUser(@RequestBody TrainingPlanDTO trainingPlanDTO, @PathVariable Long userId){
        return ResponseEntity.ok(trainingService.addReadyPlanToUser(userId, trainingPlanDTO));
    }


    @DeleteMapping("/training/{trainingId}/{userId}")
    public ResponseEntity<Void> deleteTraining(@PathVariable Long trainingId, @PathVariable Long userId) {
        trainingService.deleteTraining(trainingId, userId);
        return ResponseEntity.noContent().build();
    }

    @PutMapping("/training/{trainingId}/{userId}")
    public ResponseEntity<TrainingDTO> updateTraining(@RequestBody @Valid TrainingDTO trainingDTO, @PathVariable Long trainingId, @PathVariable Long userId) {
        return ResponseEntity.ok(trainingService.updateTraining(trainingDTO, trainingId, userId));
    }

    @GetMapping("/training/{userId}")
    public ResponseEntity<TrainingStatisticsDTO> getStatisticsForUserId(@PathVariable Long userId) {
        return ResponseEntity.ok(trainingService.getStatisticsForUserId(userId));
    }

    @GetMapping("/training/history")
    public ResponseEntity<List<TrainingDTO>> getTrainingHistory() {
        String userEmail = SecurityContextHolder.getContext().getAuthentication().getName();
        return ResponseEntity.ok(trainingService.getTrainingsForUserByEmail(userEmail));
    }


}
package com.trainify.trainifybackend.training.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import jakarta.validation.constraints.PastOrPresent;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;

public record TrainingDTO(

        Long id, // trainingId
        Long userId,

        String note,

        double intensityScore, // Wynik intensywnosci treningu 0 - 100
        String intensityScoreMessage, // Komunikat jak intensywny trening by≈Ç


        @PastOrPresent LocalDate date,
        @JsonInclude(JsonInclude.Include.NON_NULL) LocalDateTime createdAt,

        List<TrainingExerciseDTO> exercises


) {
}
package com.trainify.trainifybackend.training.dto;

import com.trainify.trainifybackend.training.model.exerciseModel.ExerciseCategory;

public record TrainingExerciseDTO(

        Long id,

        ExerciseCategory exerciseCategory,
        String exerciseName,
        String exerciseDisplayName,



        int amount,
        int duration

        ) {
}
package com.trainify.trainifybackend.training.dto;

import java.util.List;

public record TrainingPlanDTO (
        String name,
        List<TrainingExerciseDTO> exercises

){}
package com.trainify.trainifybackend.training.dto;

public record TrainingStatisticsDTO(
        double averageDuration,
        double averageAmount,
        double averageIntensityScore
        //Najczestsze cwiczenie

) {
}
package com.trainify.trainifybackend.training.model.exerciseModel;

import lombok.Getter;

@Getter
public enum AbsExercise {
    PLANK("Plank"),
    PLANK_BOCZNY("Plank boczny"),
    HOLLOW_BODY_HOLD("Hollow Body Hold"),
    HOLLOW_BODY_ROCK("Hollow Body Rock"),
    L_SIT("L-sit"),
    UNOSZENIE_KOLAN_W_ZWISIE("Unoszenie kolan w zwisie"),
    UNOSZENIE_NOG_W_ZWISIE("Unoszenie n√≥g w zwisie"),
    TOES_TO_BAR("Toes to Bar"),
    DRAGON_FLAG("Dragon Flag"),
    V_UP("V-Up"),
    RUSKIE_SKRETY("Rosyjskie skrƒôty"),
    MOUNTAIN_CLIMBER("Mountain Climber"),
    PLANK_KOLANO_DO_LOKCI("Plank z kolanem do ≈Çokcia"),
    WINDSHIELD_WIPERS("Windshield Wipers"),
    ROLLOUT_BZUCH("Rollout brzucha");

    private final String nazwa;

    AbsExercise(String nazwa) {
        this.nazwa = nazwa;
    }
}
package com.trainify.trainifybackend.training.model.exerciseModel;

import lombok.Getter;

@Getter
public enum ArmExercise {
    DIPY_NA_PORECZACH("Dipy na porƒôczach"),
    DIPY_NA_KOLKACH("Dipy na k√≥≈Çkach"),
    DIPY_IZOMETRYCZNE("Dipy izometryczne"),
    POMPKI_DIAMENTOWE("Pompki diamentowe"),
    POMPKI_WASKIE("Pompki wƒÖskie"),
    L_SIT_DO_DIPOW("L-sit do dip√≥w"),
    PODCIAGANIE_PODCHWYTEM("PodciƒÖganie podchwytem"),
    PODCIAGANIE_NEUTRALNYM_CHWYtem("PodciƒÖganie neutralnym chwytem"),
    PODCIAGANIE_Z_SUPINACJA("PodciƒÖganie z supinacjƒÖ"),
    NEGATYWNE_PODCIAGANIE_PODCHWYTEM("Negatywne podciƒÖganie podchwytem"),
    POMPKI_ARCHER("Pompki archer"),
    SLOW_DIP("Slow Dip"),
    POMPKI_WASKIE_WOLNE("Pompki wƒÖskie wolne"),
    POMPKI_PLANCHE_LEAN_RAMIONA("Pompki typu planche lean"),
    PULL_UP_EKSPL("Pull-Up Explosive");

    private final String nazwa;

    ArmExercise(String nazwa) {
        this.nazwa = nazwa;
    }
}
package com.trainify.trainifybackend.training.model.exerciseModel;

import lombok.Getter;

@Getter
public enum BackExercise {
    PODCIAGANIE_NACHWYTEM("PodciƒÖganie nachwytem"),
    PODCIAGANIE_PODCHWYTEM("PodciƒÖganie podchwytem"),
    PODCIAGANIE_NEUTRALNYM_CHWYTEM("PodciƒÖganie neutralnym chwytem"),
    PODCIAGANIE_SZEROKIM_NACHWYTEM("PodciƒÖganie szerokim nachwytem"),
    PODCIAGANIE_WASKIM_NACHWYTEM("PodciƒÖganie wƒÖskim nachwytem"),
    PODCIAGANIE_LUKOWE("PodciƒÖganie ≈Çukowe"),
    PODCIAGANIE_TYPEWRITER("PodciƒÖganie typu typewriter"),
    WIOSLOWANIE_AUSTRALIJSKIE("Wios≈Çowanie australijskie"),
    WIOSLOWANIE_POZIOME("Wios≈Çowanie poziome"),
    WIOSLOWANIE_NA_KOLKACH("Wios≈Çowanie na k√≥≈Çkach"),
    SCAPULAR_PULL_UP("Scapular Pull-Up"),
    BIRD_DOG("Bird-Dog"),
    SUPERMAN("Superman"),
    FRONT_LEVER_TUCK_HOLD("Front Lever Tuck Hold"),
    PODCIAGANIE_COMMANDO("PodciƒÖganie commando");

    private final String nazwa;

    BackExercise(String nazwa) {
        this.nazwa= nazwa;
    }
}
package com.trainify.trainifybackend.training.model.exerciseModel;

import lombok.Getter;

@Getter
public enum ChestExercise {
    POMPKI_KLASYCZNE("Pompki klasyczne"),
    POMPKI_SKOSNE("Pompki sko≈õne"),
    POMPKI_SZEROKIE("Pompki szerokie"),
    DIPY_NA_PORECZACH("Dipy na porƒôczach"),
    DIPY_NA_KOLKACH("Dipy na k√≥≈Çkach"),
    POMPKI_DIAMENTOWE("Pompki diamentowe"),
    POMPKI_ARCHER("Pompki archer"),
    POMPKI_Z_WYSUNIECIEM_RAK("Pompki z wysuniƒôciem rƒÖk"),
    POMPKI_PLANCHE_LEAN("Pompki planche lean"),
    POMPKI_TYPEWRITER("Pompki typu typewriter"),
    POMPKI_NISKI_SUPPORT("Pompki na niskim podp√≥rze"),
    POMPKI_EKSPLODUJACE("Pompki eksplodujƒÖce"),
    POMPKI_WOLNE("Pompki wolne"),
    POMPKI_SZEROKIE_KOLKA("Pompki na szerokich k√≥≈Çkach"),
    DIPY_IZOMETRYCZNE("Dipy izometryczne");  // ≈õrednik po ostatniej warto≈õci


    private final String nazwa;

    ChestExercise(String nazwa) {
        this.nazwa= nazwa;
    }

}
package com.trainify.trainifybackend.training.model.exerciseModel;

public enum ExerciseCategory {
    Klata,
    Plecy,
    Barki,
    Ramiona,
    Brzuch,
    Nogi
}
package com.trainify.trainifybackend.training.model.exerciseModel;

import lombok.Getter;

@Getter
public enum LegExercise {
    PRZYSIAD_KLASYCZNY("Przysiad klasyczny"),
    PRZYSIAD_SUMO("Przysiad sumo"),
    PRZYSIAD_BULGARSKI("Przysiad bu≈Çgarski"),
    PRZYSIAD_JEDNONOGI_PROGRESJA("Przysiad na jednej nodze ‚Äì progresja"),
    WYKROK_DO_PRZODU("Wykrok do przodu"),
    WYKROK_W_TYL("Wykrok w ty≈Ç"),
    WYKROK_BOCZNY("Wykrok boczny"),
    SKOK_W_MIEJSCU("Skok w miejscu"),
    SKOK_NA_JEDNEJ_NODZE("Skok na jednej nodze"),
    GLUTE_BRIDGE("Glute Bridge"),
    GLUTE_BRIDGE_JEDNA_NOGA("Glute Bridge na jednej nodze"),
    DONKEY_KICK("Donkey Kick"),
    WZNOSY_NA_PALCE("Wznosy na palce"),
    WALL_SIT("Wall Sit"),
    SKOK_W_DAL_Z_MIEJSCA("Skok w dal z miejsca");


    private final String nazwa;

    LegExercise(String nazwa) {
        this.nazwa= nazwa;
    }

}
package com.trainify.trainifybackend.training.model.exerciseModel;

import lombok.Getter;

@Getter
public enum ShoulderExercise {
    POMPKI_PIKE("Pompki pike"),
    POMPKI_PIKE_PODWYZSZENIE("Pompki pike na podwy≈ºszeniu"),
    POMPKI_DIVE_BOMBER("Pompki dive bomber"),
    POMPKI_HINDU("Pompki hindu"),
    WALL_HANDSTAND_HOLD("Wall Handstand Hold"),
    HANDSTAND_SHRUG("Handstand Shrug"),
    PLANCHE_LEAN("Planche Lean"),
    POMPKI_PLANCHE_LEAN("Pompki planche lean"),
    TUCK_FRONT_LEVER_HOLD("Tuck Front Lever Hold"),
    PLANK_DOTK_BARKU("Plank z dotkniƒôciem barku"),
    PLANK_DO_POZYCJI_DOG("Plank do pozycji psa z g≈ÇowƒÖ w d√≥≈Ç"),
    RING_SUPPORT_HOLD("Ring Support Hold"),
    WZNOSY_BARKOW_STANIE_REKACH("Wznosy bark√≥w w staniu na rƒôkach"),
    L_SIT_DO_TUCK_PLANCHE("L-sit do tuck planche"),
    POMPKI_EKSPLODUJACE_PIKE("Pompki eksplodujƒÖce w pike");

    private final String nazwa;

    ShoulderExercise(String nazwa) {
        this.nazwa = nazwa;
    }
}
package com.trainify.trainifybackend.training.model;


import com.trainify.trainifybackend.user.model.User;
import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;

@Entity
@Table(name = "training")
@Getter
@Setter
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class Training {


    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private LocalDate date; // data treningu
    private LocalDateTime createdAt;// kiedy wpis zosta≈Ç dodany


    private double intensityScore; // Wynik intensywnosci treningu 0 - 100
    private String intensityScoreMessage; // Komunikat jak intensywny trening by≈Ç


    String note;


    @ManyToOne
    @JoinColumn(name = "user_id")
    private User userAssigned;


    @OneToMany(mappedBy = "trainingAssigned", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<TrainingExercise> exercises;


}
package com.trainify.trainifybackend.training.model;


import com.trainify.trainifybackend.training.model.exerciseModel.ExerciseCategory;
import jakarta.persistence.*;
import lombok.*;

@Builder
@Entity
@Getter
@Setter
@Table(name = "trainingExercise")
@AllArgsConstructor
@NoArgsConstructor

public class TrainingExercise {


    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Enumerated(EnumType.ORDINAL)
    private ExerciseCategory exerciseCategory; // Kategoria ƒáwiczenia (np. Ramiona)
    private String exerciseName;  // DIPY_NA_PORECZACH
    private String exerciseDisplayName; // Dipy na porƒôczach


    private int amount; // liczba powt√≥rze≈Ñ

    private int duration; // czas w minutach cwiczenia





    @ManyToOne
    @JoinColumn(name = "training_id")
    private Training trainingAssigned;


}
package com.trainify.trainifybackend.training.repository;

import com.trainify.trainifybackend.training.model.Training;
import com.trainify.trainifybackend.training.model.TrainingExercise;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface TrainingRepository extends JpaRepository<Training, Long> {


    Optional<Training> findTrainingByIdAndUserAssigned_Id(Long trainingId, Long userId); // metoda do pobierania treningu po ID treningu i ID u≈ºytkownika

    List<Training> findAllByUserAssigned_Id(Long userId); // Pobieranie wszystkich trening√≥w danego u≈ºytkownika

}
package com.trainify.trainifybackend.training.service;

import com.trainify.trainifybackend.exception.TrainingForUserNotFoundException;
import com.trainify.trainifybackend.exception.UserNotFoundException;
import com.trainify.trainifybackend.training.dto.TrainingDTO;
import com.trainify.trainifybackend.training.dto.TrainingExerciseDTO;
import com.trainify.trainifybackend.training.dto.TrainingPlanDTO;
import com.trainify.trainifybackend.training.dto.TrainingStatisticsDTO;
import com.trainify.trainifybackend.training.model.Training;
import com.trainify.trainifybackend.training.model.TrainingExercise;
import com.trainify.trainifybackend.training.model.exerciseModel.*;
import com.trainify.trainifybackend.training.repository.TrainingRepository;
import com.trainify.trainifybackend.user.model.User;
import com.trainify.trainifybackend.user.repository.UserRepository;
import com.trainify.trainifybackend.user.service.UserService;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class TrainingService {


    private final TrainingRepository trainingRepository;
    private final UserRepository userRepository;
    private final UserService userService;

    @Transactional
    public TrainingDTO addTraining(TrainingDTO trainingDTO) {

        User user = userService.getUserById(trainingDTO.userId())
                .orElseThrow(() -> new UserNotFoundException("Nie znaleziono u≈ºytkownika z id " + trainingDTO.userId()));
        Training training = Training.builder()
                .date(trainingDTO.date())
                .createdAt(LocalDateTime.now())
                .note(trainingDTO.note())
                .intensityScore(trainingDTO.intensityScore())
                .intensityScoreMessage(trainingDTO.intensityScoreMessage())
                .userAssigned(user)
                .build();


        //Sprawdzam, czy lista ƒáwicze≈Ñ w dto istnieje i sprawdzam, czy lista nie jest pusta, je≈ºeli siƒô zgadza tworze ƒáwiczenia
        if (!CollectionUtils.isEmpty(trainingDTO.exercises())) {
            List<TrainingExercise> exercises = createExercise(trainingDTO, training);
            training.setExercises(exercises);
            calculateTiS(training);
        }


        trainingRepository.save(training);
        List<TrainingExerciseDTO> getExercise = getExercise(training);

        return new TrainingDTO(
                training.getId(),
                user.getId(),
                training.getNote(),
                training.getIntensityScore(),
                training.getIntensityScoreMessage(),
                training.getDate(),
                training.getCreatedAt(),
                getExercise
        );

    }

    @Transactional
    public TrainingDTO updateTraining(TrainingDTO trainingDTO, Long trainingId, Long userId) {
        Training existingTraining = trainingRepository.findTrainingByIdAndUserAssigned_Id(trainingId, userId)
                .orElseThrow(() -> new TrainingForUserNotFoundException(
                        "Nie znaleziono treningu o podanym ID dla tego u≈ºytkownika"
                ));


        existingTraining.setDate(trainingDTO.date()); // Najpierw zmieniasz date w istniejƒÖcym obiekcie, zanim zapiszesz go w repozytorium, to standardowa aktualizacja encji.
        existingTraining.setNote(trainingDTO.note()); // aktualizacja notatki

        //Zastƒôpuje stare ƒáwiczenia nowymi, tak ≈ºeby Hibernate poprawnie usuwa≈Ç te usuniƒôte.
        List<TrainingExercise> newExercises = createExercise(trainingDTO, existingTraining);
        if (existingTraining.getExercises() == null) {
            existingTraining.setExercises(newExercises);
        } else {
            existingTraining.getExercises().clear();
            existingTraining.getExercises().addAll(newExercises);
        }

        calculateTiS(existingTraining);
        trainingRepository.save(existingTraining);

        List<TrainingExerciseDTO> getExercise = getExercise(existingTraining);

        return new TrainingDTO(
                existingTraining.getId(),

                userId,
                existingTraining.getNote(),
                existingTraining.getIntensityScore(),
                existingTraining.getIntensityScoreMessage(),
                existingTraining.getDate(),
                existingTraining.getCreatedAt(),
                getExercise

        );
    }

    public List<TrainingExercise> createExercise(TrainingDTO trainingDTO, Training training) {
        return trainingDTO.exercises().stream()
                .map(dto -> {

                    // Pobieramy nazwƒô ƒáwiczenia i jego "przyjaznƒÖ" nazwƒô do wy≈õwietlania
                    String name = dto.exerciseName(); // np. "DIPY_NA_PORECZACH" ‚Äì nazwa w enum
                    String displayName = dto.exerciseDisplayName(); //  np. "Dipy na porƒôczach" ‚Äì do pokazania u≈ºytkownikowi

                    /* Je≈õli displayName jest puste, u≈ºywamy enum√≥w, aby dopasowaƒá technicznƒÖ nazwƒô do czytelnej nazwy
                    valueOf(name) zamienia String w odpowiadajƒÖcƒÖ sta≈ÇƒÖ enumu (np. "POMPKI_KLASYCZNE" ‚Üí ChestExercise.POMPKI_KLASYCZNE)*/
                    if (displayName == null && name != null) {
                        switch (dto.exerciseCategory()) {
                            case Klata -> displayName = ChestExercise.valueOf(name).getNazwa();
                            // valueOf(name) ‚Äì znajd≈∫ element enum ChestExercise o dok≈Çadnie tej nazwie (np. "POMPKI_KLASYCZNE")
                            // getNazwa() ‚Äì pobierz "czytelnƒÖ" nazwƒô ƒáwiczenia np. "Pompki klasyczne"
                            case Plecy -> displayName = BackExercise.valueOf(name).getNazwa();
                            case Barki -> displayName = ShoulderExercise.valueOf(name).getNazwa();
                            case Ramiona -> displayName = ArmExercise.valueOf(name).getNazwa();
                            case Brzuch -> displayName = AbsExercise.valueOf(name).getNazwa();
                            case Nogi -> displayName = LegExercise.valueOf(name).getNazwa();
                        }
                    }

                    return TrainingExercise.builder()
                            .id(dto.id())
                            .exerciseCategory(dto.exerciseCategory())
                            .exerciseName(name)
                            .exerciseDisplayName(displayName)
                            .amount(dto.amount())
                            .duration(dto.duration())
                            .trainingAssigned(training)
                            .build();
                })
                .collect(Collectors.toList());
    }


    public List<TrainingExerciseDTO> getExercise(Training training) {
        List<TrainingExercise> exercises = training.getExercises();
        if (exercises == null) {
            return Collections.emptyList();
        }
        return exercises.stream().map(
                        exercise -> new TrainingExerciseDTO(
                                exercise.getId(),
                                exercise.getExerciseCategory(),
                                exercise.getExerciseName(),
                                exercise.getExerciseDisplayName(),
                                exercise.getAmount(),
                                exercise.getDuration()
                        ))
                .collect(Collectors.toList());
    }


    public void deleteTraining(Long trainingId, Long userId) {
        Training training = trainingRepository.findTrainingByIdAndUserAssigned_Id(trainingId, userId)
                .orElseThrow(() -> new TrainingForUserNotFoundException(
                        "Nie znaleziono treningu o podanym ID dla tego u≈ºytkownika"
                ));
        trainingRepository.delete(training);

    }


    public TrainingDTO addReadyPlanToUser(Long userId, TrainingPlanDTO trainingPlanDTO) {
        User user = userService.getUserById(userId)
                .orElseThrow(() -> new UserNotFoundException("Nie znaleziono u≈ºytkownika o id " + userId));

        //Tworzymy nowy trening
        Training training = Training.builder()
                .date(LocalDate.now())
                .createdAt(LocalDateTime.now())
                .note(trainingPlanDTO.name())
                .userAssigned(user)
                .build();

        // Tworzymy listƒô ƒáwicze≈Ñ dla treningu na podstawie DTO
        List<TrainingExercise> exercises = trainingPlanDTO.exercises().stream()
                .map(dto -> {
                    String displayName = dto.exerciseDisplayName();
                    String exerciseName = dto.exerciseName();

                    if ((displayName == null || displayName.isEmpty()) && exerciseName != null) {
                        switch (dto.exerciseCategory()) {
                            case Klata -> displayName = ChestExercise.valueOf(exerciseName).getNazwa();
                            case Plecy -> displayName = BackExercise.valueOf(exerciseName).getNazwa();
                            case Barki -> displayName = ShoulderExercise.valueOf(exerciseName).getNazwa();
                            case Ramiona -> displayName = ArmExercise.valueOf(exerciseName).getNazwa();
                            case Brzuch -> displayName = AbsExercise.valueOf(exerciseName).getNazwa();
                            case Nogi -> displayName = LegExercise.valueOf(exerciseName).getNazwa();
                        }
                    }
                    // Tworzymy obiekt TrainingExercise i przypisujemy ƒáwiczenia z powy≈ºej do treningu utworzonego wcze≈õniej
                    return TrainingExercise.builder()
                            .exerciseCategory(dto.exerciseCategory())
                            .exerciseName(exerciseName)
                            .exerciseDisplayName(displayName)
                            .amount(dto.amount())
                            .duration(dto.duration())
                            .trainingAssigned(training)
                            .build();
                })
                .collect(Collectors.toList());


        training.setExercises(exercises);
        calculateTiS(training);
        trainingRepository.save(training);

        List<TrainingExerciseDTO> getExercise = getExercise(training);

        return new TrainingDTO(
                training.getId(),
                userId,
                training.getNote(),
                training.getIntensityScore(),
                training.getIntensityScoreMessage(),
                training.getDate(),
                training.getCreatedAt(),
                getExercise
        );
    }

    public TrainingStatisticsDTO getStatisticsForUserId(Long userId) {
        List<Training> trainings = trainingRepository.findAllByUserAssigned_Id(userId);

        if (trainings.isEmpty()) {
            return new TrainingStatisticsDTO(0, 0, 0);
        }


        //≈õrednia czasu ca≈Çego treningu -> sumujemy czas wszystkich ƒáwicze≈Ñ w treningu, potem ≈õrednia po treningach
        double averageDuration = trainings.stream()
                .mapToDouble(t -> t.getExercises().stream()
                        .mapToInt(TrainingExercise::getDuration)
                        .sum()
                )
                .average()
                .orElse(0.0);

        //≈õrednia liczby powt√≥rze≈Ñ -> sumujemy wszystkie ƒáwiczenia w treningu, potem ≈õrednia po treningach
        double averageAmount = trainings.stream()
                .mapToDouble(t -> t.getExercises().stream()
                        .mapToInt(TrainingExercise::getAmount)
                        .sum()
                )
                .average()
                .orElse(0.0);

        double averageIntensityScore = trainings.stream()
                .mapToDouble(Training::getIntensityScore)
                .average()
                .orElse(0.0);

        return new TrainingStatisticsDTO(averageDuration, averageAmount, averageIntensityScore);
    }

    public List<TrainingDTO> getTrainingsForUserByEmail(String email) {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException("Nie znaleziono u≈ºytkownika po emailu " + email));
        List<Training> trainings = trainingRepository.findAllByUserAssigned_Id(user.getId());

        return trainings.stream()
                .map(this::mapToTrainingDTO)
                .collect(Collectors.toList());
    }

    private TrainingDTO mapToTrainingDTO(Training training) {
        return new TrainingDTO(
                training.getId(),
                training.getUserAssigned().getId(),
                training.getNote(),
                training.getIntensityScore(),
                training.getIntensityScoreMessage(),
                training.getDate(),
                training.getCreatedAt(),
                getExercise(training)
        );
    }


    public void calculateTiS(Training training) {


        if (training.getExercises() == null || training.getExercises().isEmpty()) {
            training.setIntensityScore(0);
            training.setIntensityScoreMessage("Brak ƒáwicze≈Ñ w treningu");
            return;
        }


        int totalDuration = training.getExercises().stream()
                .mapToInt(TrainingExercise::getDuration)
                .sum();
        int totalAmount = training.getExercises().stream()
                .mapToInt(TrainingExercise::getAmount)
                .sum();

      /*  Math.min(..., 100) = maksymalnie 100, Math.max(0, ...) = minimalnie 0
          Najpierw ograniczam g√≥rnƒÖ granicƒô, potem dolnƒÖ, wynik zawsze w przedziale 0‚Äì100

         Normalizacja czasu i ilo≈õci powt√≥rze≈Ñ do zakresu 0‚Äì1
         80 minut i 500 powt√≥rze≈Ñ to maksymalne warto≈õci przy pe≈Çnym wyniku*/
        double calculateDuration = Math.min(totalDuration / 60.0, 1.0);
        double calculateAmount = Math.min(totalAmount / 300.0, 1.0);

        double TiS = (calculateDuration * 0.5 + calculateAmount * 0.5) * 100;
        String feedback;

        if (TiS < 40) feedback = "Lekki Trening";
        else if (TiS < 70) feedback = "Dobry trening";
        else feedback = "Bardzo dobry trening";


        training.setIntensityScore(TiS);
        training.setIntensityScoreMessage(feedback);

    }

}
package com.trainify.trainifybackend.user.controller;


import com.trainify.trainifybackend.user.dto.UserRegisterLoginDTO;
import com.trainify.trainifybackend.user.service.UserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

@RequiredArgsConstructor
@RestController
public class UserController {

    private final UserService userService;


    @PostMapping("/register")
    public ResponseEntity<UserRegisterLoginDTO> registerUser(@RequestBody @Valid UserRegisterLoginDTO userRegisterLoginDTO) {
        return ResponseEntity.ok(userService.registerUser(userRegisterLoginDTO));
    }

    @PostMapping("/login")
    public ResponseEntity<UserRegisterLoginDTO> loginUser(@RequestBody @Valid UserRegisterLoginDTO userLogin) {
        return ResponseEntity.ok(userService.loginUser(userLogin.email(), userLogin.password()));
    }
}

package com.trainify.trainifybackend.user.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;


public record UserRegisterLoginDTO(
        Long id,
        String username,
        @NotBlank
        String password,

        @Email
        String email,

        String jwtToken

) {
}
package com.trainify.trainifybackend.user.model;

import com.trainify.trainifybackend.dailywellness.model.DailyWellness;
import com.trainify.trainifybackend.healthcore.model.UserHealthMetrics;
import com.trainify.trainifybackend.training.model.Training;
import jakarta.persistence.*;
import lombok.*;
import org.springframework.security.config.annotation.web.oauth2.client.OAuth2ClientSecurityMarker;

import java.time.LocalDateTime;
import java.util.List;

@Entity
@Table(name = "users")
@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Builder
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;


    private String username;
    private String password;
    private String email;
    private LocalDateTime createdAt;


    @OneToMany(mappedBy = "userAssigned", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Training> trainings;

    @OneToMany(mappedBy = "userAssigned")
    private List<DailyWellness> dailyWellnessHistory;


    @OneToMany(mappedBy = "userAssigned")
    private List<UserHealthMetrics> userHealthMetrics;
}
package com.trainify.trainifybackend.user.repository;

import com.trainify.trainifybackend.user.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {

    Optional<User>findByEmail(String email); // metoda do znajdowania u≈ºytkownika po nazwie u≈ºytkownika lub emailu



    boolean existsByUsername(String username); // metoda do sprawdzania czy istnieje u≈ºytkownik o danej nazwie u≈ºytkownika
    boolean existsByEmail(String email); // metoda do sprawdzania czy istnieje u≈ºytkownik o danym emailu
}
package com.trainify.trainifybackend.user.service;

import com.trainify.trainifybackend.exception.EmailAlreadyExistsException;
import com.trainify.trainifybackend.exception.UserNotFoundException;
import com.trainify.trainifybackend.exception.UsernameAlreadyExistsException;
import com.trainify.trainifybackend.exception.WrongPasswordException;
import com.trainify.trainifybackend.security.service.JwtService;
import com.trainify.trainifybackend.user.dto.UserRegisterLoginDTO;
import com.trainify.trainifybackend.user.model.User;
import com.trainify.trainifybackend.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Service
@RequiredArgsConstructor
public class UserService {


    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtService jwtService;
    private final AuthenticationManager authenticationManager;


    public UserRegisterLoginDTO registerUser(UserRegisterLoginDTO userRegisterLoginDTO) {

        if (userRepository.existsByUsername(userRegisterLoginDTO.username())) {
            throw new UsernameAlreadyExistsException("Nazwa u≈ºytkownika jest ju≈º zajƒôta");
        }

        if (userRepository.existsByEmail(userRegisterLoginDTO.email())) {
            throw new EmailAlreadyExistsException("Email jest ju≈º zajƒôty");
        }


        User user = User.builder()
                .username(userRegisterLoginDTO.username())
                .email(userRegisterLoginDTO.email())
                .password(passwordEncoder.encode(userRegisterLoginDTO.password())) // hashowanie has≈Ça
                .createdAt(LocalDateTime.now())
                .build();
        User savedUser = userRepository.save(user);

        String jwtToken = jwtService.generateToken(
                new org.springframework.security.core.userdetails.User(
                        savedUser.getEmail(),
                        savedUser.getPassword(),
                        List.of()
                )
        );

        return new UserRegisterLoginDTO(user.getId(),savedUser.getUsername(), null, savedUser.getEmail(), jwtToken);

    }

    public UserRegisterLoginDTO loginUser(String email, String rawPassword) {
        try {
            authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(email, rawPassword)
            );
        } catch (AuthenticationException e) {
            throw new WrongPasswordException("Nieprawid≈Çowy email lub has≈Ço");
        }


        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException("Nie znaleziono u≈ºytkownika"));


        UserDetails userDetails = new org.springframework.security.core.userdetails.User(
                user.getEmail(),
                user.getPassword(),
                List.of()
        );
        String jwtToken = jwtService.generateToken(userDetails);

        return new UserRegisterLoginDTO(user.getId(),user.getUsername(), null, user.getEmail(), jwtToken);
    }


    public Optional<User> getUserById(Long userId) {
        return userRepository.findById(userId);
    }


}
package com.trainify.trainifybackend;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableAsync;

@EnableAsync
@SpringBootApplication
public class TrainifyBackendApplication {

	public static void main(String[] args) {
		SpringApplication.run(TrainifyBackendApplication.class, args);
	}

}
package com.trainify.trainifybackend;

import com.trainify.trainifybackend.user.service.UserService;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class TrainifyBackendApplicationTests {
	@Test
	void contextLoads() {
	}

}
