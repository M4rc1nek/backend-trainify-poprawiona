package com.trainify.trainifybackend.config;

import com.trainify.trainifybackend.exception.UserNotFoundException;
import com.trainify.trainifybackend.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
@RequiredArgsConstructor
public class ApplicationConfig {

    private final UserRepository userRepository; // Wstrzykniƒôcie repozytorium u≈ºytkownik√≥w

    //Wczytywanie  u≈ºytkownika i zwracanie uzytkownika z zahashowanym haslem i rolami
    @Bean
    public UserDetailsService userDetailsService() {
        return username -> userRepository.findByEmail(username) // Spring Security u≈ºyje "username", ale u nas to jest email
                .map(user -> org.springframework.security.core.userdetails.User.builder() // Mapowanie (zamiana) naszej klasy User na UserDetails
                        .username(user.getEmail())
                        .password(user.getPassword())
                        // W prostym projekcie nie u≈ºywamy r√≥l, ale je≈õli chcesz, dodaj np. .roles("USER")
                        .build())
                .orElseThrow(() -> new UserNotFoundException("Nie znaleziono u≈ºytkownika"));
    }

    // 2. Provider uwierzytelniania, pobiera haslo od uzytkownika i prosi UserDetailsService o za≈Çadaowanie zahashowanego has≈Ça z bazy
    // A nastepnie prosi PasswordEncoder o sprawdzenie czy te dwa hasla do siebie pasuja (cos typu .matches)
    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService()); // Ustawienie serwisu do ≈Çadowania u≈ºytkownika
        authProvider.setPasswordEncoder(passwordEncoder()); // Ustawienie kodera has≈Ça
        return authProvider;
    }

    // 3. Manager uwierzytelniania (Kieruje
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception { // Uwierzytelnia uzytkownikow (np. sprawdzenie loginu, hasla)
        return config.getAuthenticationManager(); // zwraca w pe≈Çni skonfigurowany obiekt AuthenticationManager
    }

    // 4. Koder has≈Ça
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
package com.trainify.trainifybackend.config;

import com.trainify.trainifybackend.security.JwtAuthenticationFilter;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;
import java.util.List;

@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityFilterChainConfig {

    private final JwtAuthenticationFilter jwtAuthFilter;
    private final AuthenticationProvider authenticationProvider;


    //Polaczenie z frontendem
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();

        configuration.setAllowedOrigins(List.of("http://localhost:5173"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }


    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        //W≈ÇƒÖczenie CORS i wy≈ÇƒÖczenie CSRF
        http
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .csrf(csrf -> csrf.disable())

                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/register", "/login").permitAll() //register, /login ‚Üí dostƒôp dla wszystkich (nie trzeba tokena JWT).
                        .requestMatchers("/training/**").authenticated() //training/** ‚Üí dostƒôp tylko dla zalogowanych u≈ºytkownik√≥w (czyli muszƒÖ mieƒá wa≈ºny token JWT).
                        .anyRequest().authenticated()    //anyRequest().authenticated() ‚Üí ka≈ºde inne ≈ºƒÖdanie te≈º wymaga zalogowania.
                )
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) // ‚ÄûNie tw√≥rz sesji, nie zapamiƒôtuj zalogowanego u≈ºytkownika ‚Äî wszystko opiera siƒô na tokenie JWT"
                .authenticationProvider(authenticationProvider) // Mowi Springowi jak ma sprawdzac dane
                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class); // Wstaw m√≥j filtr JWT przed tym standardowym, ≈ºeby token by≈Ç sprawdzony, zanim Spring zacznie swoje logowanie

        return http.build();
    }
}
package com.trainify.trainifybackend.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("http://localhost:5173")
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(true);
    }
}
package com.trainify.trainifybackend.exception;

public class EmailAlreadyExistsException extends RuntimeException {
    public EmailAlreadyExistsException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.exception;

public record ErrorResponseDTO(
        int status,      // kod HTTP (np. 400, 404, 500)
        String error,    // kr√≥tki opis b≈Çƒôdu (np. "Bad Request")
        String message,  // szczeg√≥≈Çowy komunikat (np. "Email jest ju≈º zajƒôty")
        String path,     // endpoint kt√≥ry wywo≈Ça≈Ç blƒÖd np ("/register")
        long timestamp   // czas w milisekundach od 01.01.1970 (Unix epoch), kiedy wyjƒÖtek wystƒÖpi≈Ç.,
        // Przyk≈Çad: 1734500000000 ‚Üí u≈Çatwia debugowanie i ≈õledzenie w logach
) {

    // Konstruktor u≈ÇatwiajƒÖcy ustawienie timestamp automatycznie
    public ErrorResponseDTO(int status, String error, String message, String path){
        this(status,error,message,path, System.currentTimeMillis());
    }
}
package com.trainify.trainifybackend.exception;


import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.context.request.WebRequest;

@Slf4j
@RestControllerAdvice // -> Dzia≈Ça globalnie na wszystkie kontrolery, zwraca JSON
public class GlobalExceptionHandler {


    /*
           CONFLICT (409) ‚Üí konflikt danych (np. email ju≈º istnieje)
           NOT_FOUND (404) ‚Üí brak danych (np. u≈ºytkownik nie istnieje)
           BAD_REQUEST (400) ‚Üí b≈Çƒôdne dane wej≈õciowe (np. niepoprawny format)
           UNAUTHORIZED (401) ‚Üí nieprawid≈Çowe logowanie lub brak autoryzacji


    webRequest.getDescription(false) - Pobiera opis ≈ºƒÖdania path, np.  /register lub /login
    Je≈õli dasz true, wynik zawiera≈Çby te≈º informacje o kliencie (np. IP, host)
     */

    @ExceptionHandler({EmailAlreadyExistsException.class, UsernameAlreadyExistsException.class})
    public ResponseEntity<ErrorResponseDTO> handleConflictExceptions(RuntimeException exception, WebRequest webRequest) {
        ErrorResponseDTO body = new ErrorResponseDTO(
                HttpStatus.CONFLICT.value(),
                HttpStatus.CONFLICT.getReasonPhrase(),
                exception.getMessage(),
                webRequest.getDescription(false).replace("uri=", "")
        );
        return new ResponseEntity<>(body, HttpStatus.CONFLICT);
    }


    @ExceptionHandler({TrainingForUserNotFoundException.class, UserNotFoundException.class})
    public ResponseEntity<ErrorResponseDTO> handleNotFoundExceptions(RuntimeException exception, WebRequest webRequest) {
        ErrorResponseDTO body = new ErrorResponseDTO(
                HttpStatus.NOT_FOUND.value(),
                HttpStatus.NOT_FOUND.getReasonPhrase(),
                exception.getMessage(),
                webRequest.getDescription(false).replace("uri=", "")
        );
        return new ResponseEntity<>(body, HttpStatus.NOT_FOUND);
    }


    @ExceptionHandler(WrongPasswordException.class)
    public ResponseEntity<ErrorResponseDTO> handleWrongPassword(WrongPasswordException exception, WebRequest webRequest) {
        ErrorResponseDTO body = new ErrorResponseDTO(
                HttpStatus.UNAUTHORIZED.value(),
                HttpStatus.UNAUTHORIZED.getReasonPhrase(),
                exception.getMessage(),
                webRequest.getDescription(false).replace("uri=", "")
        );
        return new ResponseEntity<>(body, HttpStatus.UNAUTHORIZED);
    }


    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponseDTO> handleAll(Exception exception, WebRequest webRequest) {
        ErrorResponseDTO body = new ErrorResponseDTO(
                HttpStatus.INTERNAL_SERVER_ERROR.value(),
                HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase(),
                "WystƒÖpi≈Ç nieoczekiwany b≈ÇƒÖd. Skontaktuj siƒô z administratorem.",
                webRequest.getDescription(false).replace("uri=", "")
        );
        return new ResponseEntity<>(body, HttpStatus.INTERNAL_SERVER_ERROR);
    }



}
package com.trainify.trainifybackend.exception;

public class TrainingForUserNotFoundException extends RuntimeException {
    public TrainingForUserNotFoundException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.exception;

public class UsernameAlreadyExistsException extends RuntimeException {
    public UsernameAlreadyExistsException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.exception;

public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.exception;

public class WrongPasswordException extends RuntimeException {
    public WrongPasswordException(String message) {
        super(message);
    }
}
package com.trainify.trainifybackend.security.service;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

import java.security.Key;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

@Service
public class JwtService {

    // üîë Tajny klucz do podpisywania token√≥w.
    // Powinien byƒá przechowywany w application.properties i byƒá silny (min. 256 bit, czyli 32 znaki base64).
    @Value("${application.security.jwt.secret-key}")
    private String secretKey;

    // ‚è± Czas wyga≈õniƒôcia tokena (np. 24 godziny)
    @Value("${application.security.jwt.expiration}")
    private long jwtExpiration;

    // --- Metody publiczne ---

    // 1. Ekstrakcja nazwy u≈ºytkownika (email) z tokena
    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    // 2. Generowanie tokena dla UserDetails (u≈ºytkownik)
    public String generateToken(UserDetails userDetails) {
        return generateToken(new HashMap<>(), userDetails);
    }

    // 3. Sprawdzenie, czy token jest wa≈ºny dla danego u≈ºytkownika
    public boolean isTokenValid(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername())) && !isTokenExpired(token);
    }


    // --- Metody prywatne (pomocnicze) ---

    // Ekstrakcja pojedynczej 'claims' (danych) z tokena
    private <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    // Generowanie tokena z dodatkowymi danymi ('extraClaims')
    private String generateToken(
            Map<String, Object> extraClaims,
            UserDetails userDetails
    ) {
        return Jwts
                .builder() // Rozpoczƒôcie budowania tokena
                .setClaims(extraClaims) // Dodatkowe claims
                .setSubject(userDetails.getUsername()) // Temat (zazwyczaj nazwa u≈ºytkownika/email)
                .setIssuedAt(new Date(System.currentTimeMillis())) // Czas utworzenia
                .setExpiration(new Date(System.currentTimeMillis() + jwtExpiration)) // Czas wyga≈õniƒôcia
                .signWith(getSignInKey(), SignatureAlgorithm.HS256) // Podpisanie kluczem SHA-256
                .compact(); // Zbudowanie i zwr√≥cenie jako String
    }

    // Sprawdzenie, czy token wygas≈Ç
    private boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    // Ekstrakcja daty wyga≈õniƒôcia
    private Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    // Ekstrakcja wszystkich 'claims' (danych) z tokena
    private Claims extractAllClaims(String token) {
        return Jwts
                .parserBuilder() // Uruchomienie parsera
                .setSigningKey(getSignInKey()) // U≈ºycie tajnego klucza
                .build()
                .parseClaimsJws(token) // Parsowanie tokena
                .getBody(); // Pobranie zawarto≈õci (claims)
    }

    // Pobranie tajnego klucza do podpisu
    private Key getSignInKey() {
        byte[] keyBytes = Decoders.BASE64.decode(secretKey); // Dekodowanie klucza z Base64
        return Keys.hmacShaKeyFor(keyBytes); // Zbudowanie klucza
    }
}
package com.trainify.trainifybackend.security;

import com.trainify.trainifybackend.security.service.JwtService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {  // OncePerRequestFilter ‚Äî zapewnia, ≈ºe filtr wykona siƒô tylko raz na ka≈ºde ≈ºƒÖdanie HTTP.

    private final JwtService jwtService;
    private final UserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(
            @NonNull HttpServletRequest request,
            @NonNull HttpServletResponse response,
            @NonNull FilterChain filterChain // Zbi√≥r filtr√≥w, przez kt√≥re ma przej≈õƒá ≈ºƒÖdanie
    ) throws ServletException, IOException {

        final String authHeader = request.getHeader("Authorization"); // Pobranie nag≈Ç√≥wka "Authorization", to tutaj frontend przesy≈Ça token JWT
        final String jwt;
        final String userEmail;

        // 1. Sprawdzenie, czy nag≈Ç√≥wek istnieje i zaczyna siƒô od "Bearer "
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response); // Przekazanie do kolejnego filtra
            return;
        }

        jwt = authHeader.substring(7); // Obcina pierwsze 7 znak√≥w ("Bearer ") i zostawia sam token JWT. Przyk≈Çad:"Bearer abc.def.ghi" ‚Üí "abc.def.ghi"
        userEmail = jwtService.extractUsername(jwt); // U≈ºywa mojego JwtService zeby wyciagnac email uzytkownika (Bo w tokenie zapisuje jego adres email)

        // 2. Warunek sprawdzajacy czy token faktycznie zawiera email i czy nikt jeszcze nie jest zalogowany
        if (userEmail != null && SecurityContextHolder.getContext().getAuthentication() == null) {

            // Wczytanie szczeg√≥≈Ç√≥w u≈ºytkownika (UserDetails) z bazy na podstawie emaila u≈ºytkownika
            UserDetails userDetails = this.userDetailsService.loadUserByUsername(userEmail);


            // 3. Sprawdza czy token JWT jest wa≈ºny i prawid≈Çowy
            //Jezeli token jest wazny i prawidlowy, tworzymy obiekt uwierzytelnienia ktory mowi "ten uzytkownik jest zalogowany"
            if (jwtService.isTokenValid(jwt, userDetails)) {

                // Tworzenie obiektu uwierzytelnienia Spring Security
                UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                        userDetails,
                        null, // JWT nie przechowuje has≈Ça, wiƒôc null
                        userDetails.getAuthorities() // Uprawnienia (role)
                );

                // Dodanie szczeg√≥≈Ç√≥w ≈ºƒÖdania do tokena (np. IP, sesja)
                authToken.setDetails(
                        new WebAuthenticationDetailsSource().buildDetails(request)
                );

                // 4. Ustawia w globalnym kontek≈õcie Spring Security, ≈ºe ten u≈ºytkownik jest zalogowany (NAJWA≈ªNIEJSZA LINIA)
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }
        filterChain.doFilter(request, response); // Przekazanie do kolejnego filtra/kontrolera
    }
}
package com.trainify.trainifybackend.training.controller;


import com.trainify.trainifybackend.training.dto.TrainingDTO;
import com.trainify.trainifybackend.training.dto.TrainingStatisticsDTO;
import com.trainify.trainifybackend.training.service.TrainingService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequiredArgsConstructor
public class TrainingController {

    private final TrainingService trainingService;


    @PostMapping("/training")
    public ResponseEntity<TrainingDTO> addTraining(@RequestBody @Valid TrainingDTO trainingDTO) {
        return ResponseEntity.ok(trainingService.addTraining(trainingDTO));
    }


    @DeleteMapping("/training/{trainingId}/{userId}")
    public ResponseEntity<Void> deleteTraining(@PathVariable Long trainingId, @PathVariable Long userId) {
        trainingService.deleteTraining(trainingId, userId);
        return ResponseEntity.noContent().build();
    }

    @PutMapping("/training/{trainingId}/{userId}")
    public ResponseEntity<TrainingDTO> updateTraining(@RequestBody @Valid TrainingDTO trainingDTO, @PathVariable Long trainingId, @PathVariable Long userId) {
        return ResponseEntity.ok(trainingService.updateTraining(trainingDTO, trainingId, userId));
    }

    @GetMapping("/training/{userId}")
    public ResponseEntity<TrainingStatisticsDTO> getStatisticsForUserId(@PathVariable Long userId) {
        return ResponseEntity.ok(trainingService.getStatisticsForUserId(userId));
    }

    @GetMapping("/training/history")
    public ResponseEntity<List<TrainingDTO>> getTrainingHistory() {
        String userEmail = SecurityContextHolder.getContext().getAuthentication().getName();
        return ResponseEntity.ok(trainingService.getTrainingsForUserByEmail(userEmail));
    }


}
package com.trainify.trainifybackend.training.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import jakarta.validation.constraints.PastOrPresent;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;

public record TrainingDTO(

        Long id,
        Long userId,

        String note,

        @PastOrPresent LocalDate date,
        @JsonInclude(JsonInclude.Include.NON_NULL) LocalDateTime createdAt,

        List<TrainingExerciseDTO> exercises


) {
}
package com.trainify.trainifybackend.training.dto;

import com.trainify.trainifybackend.training.model.ExerciseCategory;

public record TrainingExerciseDTO(

        Long id,

        ExerciseCategory exerciseCategory,

        int amount,
        int duration

        ) {
}
package com.trainify.trainifybackend.training.dto;

public record TrainingStatisticsDTO(
        double averageDuration,
        double averageAmount,
        double averageIntensityScore
        //Najczestsze cwiczenie

) {
}
package com.trainify.trainifybackend.training.model;

import lombok.Getter;

@Getter
public enum AbsExercise {
    PLANK("Plank"),
    PLANK_BOCZNY("Plank boczny"),
    HOLLOW_BODY_HOLD("Hollow Body Hold"),
    HOLLOW_BODY_ROCK("Hollow Body Rock"),
    L_SIT("L-sit"),
    UNOSZENIE_KOLAN_W_ZWISIE("Unoszenie kolan w zwisie"),
    UNOSZENIE_NOG_W_ZWISIE("Unoszenie n√≥g w zwisie"),
    TOES_TO_BAR("Toes to Bar"),
    DRAGON_FLAG("Dragon Flag"),
    V_UP("V-Up"),
    RUSKIE_SKRETY("Rosyjskie skrƒôty"),
    MOUNTAIN_CLIMBER("Mountain Climber"),
    PLANK_KOLANO_DO_LOKCI("Plank z kolanem do ≈Çokcia"),
    WINDSHIELD_WIPERS("Windshield Wipers"),
    ROLLOUT_BZUCH("Rollout brzucha");

    private final String nazwa;

    AbsExercise(String nazwa) {
        this.nazwa = nazwa;
    }
}
package com.trainify.trainifybackend.training.model;

import lombok.Getter;

@Getter
public enum ArmExercise {
    DIPY_NA_PORECZACH("Dipy na porƒôczach"),
    DIPY_NA_KOLKACH("Dipy na k√≥≈Çkach"),
    DIPY_IZOMETRYCZNE("Dipy izometryczne"),
    POMPKI_DIAMENTOWE("Pompki diamentowe"),
    POMPKI_WASKIE("Pompki wƒÖskie"),
    L_SIT_DO_DIPOW("L-sit do dip√≥w"),
    PODCIAGANIE_PODCHWYTEM("PodciƒÖganie podchwytem"),
    PODCIAGANIE_NEUTRALNYM_CHWYtem("PodciƒÖganie neutralnym chwytem"),
    PODCIAGANIE_Z_SUPINACJA("PodciƒÖganie z supinacjƒÖ"),
    NEGATYWNE_PODCIAGANIE_PODCHWYTEM("Negatywne podciƒÖganie podchwytem"),
    POMPKI_ARCHER("Pompki archer"),
    SLOW_DIP("Slow Dip"),
    POMPKI_WASKIE_WOLNE("Pompki wƒÖskie wolne"),
    POMPKI_PLANCHE_LEAN_RAMIONA("Pompki typu planche lean"),
    PULL_UP_EKSPL("Pull-Up Explosive");

    private final String nazwa;

    ArmExercise(String nazwa) {
        this.nazwa = nazwa;
    }
}
package com.trainify.trainifybackend.training.model;

import lombok.Getter;

@Getter
public enum BackExercise {
    PODCIAGANIE_NACHWYTEM("PodciƒÖganie nachwytem"),
    PODCIAGANIE_PODCHWYTEM("PodciƒÖganie podchwytem"),
    PODCIAGANIE_NEUTRALNYM_CHWYTEM("PodciƒÖganie neutralnym chwytem"),
    PODCIAGANIE_SZEROKIM_NACHWYTEM("PodciƒÖganie szerokim nachwytem"),
    PODCIAGANIE_WASKIM_NACHWYTEM("PodciƒÖganie wƒÖskim nachwytem"),
    PODCIAGANIE_LUKOWE("PodciƒÖganie ≈Çukowe"),
    PODCIAGANIE_TYPEWRITER("PodciƒÖganie typu typewriter"),
    WIOSLOWANIE_AUSTRALIJSKIE("Wios≈Çowanie australijskie"),
    WIOSLOWANIE_POZIOME("Wios≈Çowanie poziome"),
    WIOSLOWANIE_NA_KOLKACH("Wios≈Çowanie na k√≥≈Çkach"),
    SCAPULAR_PULL_UP("Scapular Pull-Up"),
    BIRD_DOG("Bird-Dog"),
    SUPERMAN("Superman"),
    FRONT_LEVER_TUCK_HOLD("Front Lever Tuck Hold"),
    PODCIAGANIE_COMMANDO("PodciƒÖganie commando");

    private final String nazwa;

    BackExercise(String nazwa) {
        this.nazwa = nazwa;
    }
}
package com.trainify.trainifybackend.training.model;

import lombok.Getter;

@Getter
public enum ChestExercise {
    POMPKI_KLASYCZNE("Pompki klasyczne"),
    POMPKI_SKOSNE("Pompki sko≈õne"),
    POMPKI_SZEROKIE("Pompki szerokie"),
    DIPY_NA_PORECZACH("Dipy na porƒôczach"),
    DIPY_NA_KOLKACH("Dipy na k√≥≈Çkach"),
    POMPKI_DIAMENTOWE("Pompki diamentowe"),
    POMPKI_ARCHER("Pompki archer"),
    POMPKI_Z_WYSUNIECIEM_RAK("Pompki z wysuniƒôciem rƒÖk"),
    POMPKI_PLANCHE_LEAN("Pompki planche lean"),
    POMPKI_TYPEWRITER("Pompki typu typewriter"),
    POMPKI_NISKI_SUPPORT("Pompki na niskim podp√≥rze"),
    POMPKI_EKSPLODUJACE("Pompki eksplodujƒÖce"),
    POMPKI_WOLNE("Pompki wolne"),
    POMPKI_SZEROKIE_KOLKA("Pompki na szerokich k√≥≈Çkach"),
    DIPY_IZOMETRYCZNE("Dipy izometryczne");  // ≈õrednik po ostatniej warto≈õci

    private final String nazwa;  // pole do przechowywania czytelnej nazwy

    // prywatny konstruktor enum
    ChestExercise(String nazwa) {
        this.nazwa = nazwa;
    }

}
package com.trainify.trainifybackend.training.model;

public enum ExerciseCategory {
    Klata,
    Plecy,
    Barki,
    Ramiona,
    Brzuch,
    Nogi
}
package com.trainify.trainifybackend.training.model;

import lombok.Getter;

@Getter
public enum LegExercise {
    PRZYSIAD_KLASYCZNY("Przysiad klasyczny"),
    PRZYSIAD_SUMO("Przysiad sumo"),
    PRZYSIAD_BULGARSKI("Przysiad bu≈Çgarski"),
    PRZYSIAD_JEDNONOGI_PROGRESJA("Przysiad na jednej nodze ‚Äì progresja"),
    WYKROK_DO_PRZODU("Wykrok do przodu"),
    WYKROK_W_TYL("Wykrok w ty≈Ç"),
    WYKROK_BOCZNY("Wykrok boczny"),
    SKOK_W_MIEJSCU("Skok w miejscu"),
    SKOK_NA_JEDNEJ_NODZE("Skok na jednej nodze"),
    GLUTE_BRIDGE("Glute Bridge"),
    GLUTE_BRIDGE_JEDNA_NOGA("Glute Bridge na jednej nodze"),
    DONKEY_KICK("Donkey Kick"),
    WZNOSY_NA_PALCE("Wznosy na palce"),
    WALL_SIT("Wall Sit"),
    SKOK_W_DAL_Z_MIEJSCA("Skok w dal z miejsca");

    private final String nazwa;

    LegExercise(String nazwa) {
        this.nazwa = nazwa;
    }
}
package com.trainify.trainifybackend.training.model;

import lombok.Getter;

@Getter
public enum ShoulderExercise {
    POMPKI_PIKE("Pompki pike"),
    POMPKI_PIKE_PODWYZSZENIE("Pompki pike na podwy≈ºszeniu"),
    POMPKI_DIVE_BOMBER("Pompki dive bomber"),
    POMPKI_HINDU("Pompki hindu"),
    WALL_HANDSTAND_HOLD("Wall Handstand Hold"),
    HANDSTAND_SHRUG("Handstand Shrug"),
    PLANCHE_LEAN("Planche Lean"),
    POMPKI_PLANCHE_LEAN("Pompki planche lean"),
    TUCK_FRONT_LEVER_HOLD("Tuck Front Lever Hold"),
    PLANK_DOTK_BARKU("Plank z dotkniƒôciem barku"),
    PLANK_DO_POZYCJI_DOG("Plank do pozycji psa z g≈ÇowƒÖ w d√≥≈Ç"),
    RING_SUPPORT_HOLD("Ring Support Hold"),
    WZNOSY_BARKOW_STANIE_REKACH("Wznosy bark√≥w w staniu na rƒôkach"),
    L_SIT_DO_TUCK_PLANCHE("L-sit do tuck planche"),
    POMPKI_EKSPLODUJACE_PIKE("Pompki eksplodujƒÖce w pike");

    private final String nazwa;

    ShoulderExercise(String nazwa) {
        this.nazwa = nazwa;
    }
}
package com.trainify.trainifybackend.training.model;


import com.trainify.trainifybackend.user.model.User;
import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;

@Entity
@Table(name = "training")
@Getter
@Setter
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class Training {


    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private LocalDate date; // data treningu
    private LocalDateTime createdAt;// kiedy wpis zosta≈Ç dodany


    private double intensityScore; // Wynik intensywnosci treningu 0 - 100
    private String intensityScoreMessage; // Komunikat jak intensywny trening by≈Ç

    String note;


    @ManyToOne
    @JoinColumn(name = "user_id")
    private User userAssigned;


    @OneToMany(mappedBy = "trainingAssigned", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<TrainingExercise> exercises;


}
package com.trainify.trainifybackend.training.model;


import jakarta.persistence.*;
import lombok.*;

@Builder
@Entity
@Getter
@Setter
@Table(name = "trainingExercise")
@AllArgsConstructor
@NoArgsConstructor

public class TrainingExercise {


    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private ExerciseCategory exerciseCategory; // kategoria ƒáwiczenia

    private int amount; // liczba powt√≥rze≈Ñ

    private int duration; // czas w minutach cwiczenia


    @ManyToOne
    @JoinColumn(name = "training_id")
    private Training trainingAssigned;


}
package com.trainify.trainifybackend.training.repository;

import com.trainify.trainifybackend.training.model.Training;
import com.trainify.trainifybackend.training.model.TrainingExercise;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface TrainingRepository extends JpaRepository<Training, Long> {


    Optional<Training> findTrainingByIdAndUserAssigned_Id(Long trainingId, Long userId); // metoda do pobierania treningu po ID treningu i ID u≈ºytkownika

    List<Training> findAllByUserAssigned_Id(Long userId); // Pobieranie wszystkich trening√≥w danego u≈ºytkownika

}
package com.trainify.trainifybackend.training.service;

import com.trainify.trainifybackend.exception.TrainingForUserNotFoundException;
import com.trainify.trainifybackend.exception.UserNotFoundException;
import com.trainify.trainifybackend.training.dto.TrainingDTO;
import com.trainify.trainifybackend.training.dto.TrainingExerciseDTO;
import com.trainify.trainifybackend.training.dto.TrainingStatisticsDTO;
import com.trainify.trainifybackend.training.model.Training;
import com.trainify.trainifybackend.training.model.TrainingExercise;
import com.trainify.trainifybackend.training.repository.TrainingRepository;
import com.trainify.trainifybackend.user.model.User;
import com.trainify.trainifybackend.user.repository.UserRepository;
import com.trainify.trainifybackend.user.service.UserService;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import java.time.LocalDateTime;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class TrainingService {


    private final TrainingRepository trainingRepository;
    private final UserRepository userRepository;
    private final UserService userService;

    @Transactional
    public TrainingDTO addTraining(TrainingDTO trainingDTO) {

        User user = userService.getUserById(trainingDTO.userId())
                .orElseThrow(() -> new UserNotFoundException("Nie znaleziono u≈ºytkownika z id " + trainingDTO.userId()));
        Training training = Training.builder()
                .date(trainingDTO.date())
                .createdAt(LocalDateTime.now())
                .note(trainingDTO.note())
                .userAssigned(user)
                .build();


        //Sprawdzam, czy lista ƒáwicze≈Ñ w dto istnieje i sprawdzam, czy lista nie jest pusta, je≈ºeli siƒô zgadza tworze ƒáwiczenia
        if(!CollectionUtils.isEmpty(trainingDTO.exercises())){
            List<TrainingExercise> exercises = createExercise(trainingDTO, training);
            training.setExercises(exercises);
            calculateTiS(training);
        }


        trainingRepository.save(training);
        List<TrainingExerciseDTO> getExercise = getExercise(training);

        return new TrainingDTO(
                training.getId(),
                user.getId(),
                training.getNote(),
                training.getDate(),
                training.getCreatedAt(),
                getExercise
        );

    }

    @Transactional
    public TrainingDTO updateTraining(TrainingDTO trainingDTO, Long trainingId, Long userId) {
        Training existingTraining = trainingRepository.findTrainingByIdAndUserAssigned_Id(trainingId, userId)
                .orElseThrow(() -> new TrainingForUserNotFoundException(
                        "Nie znaleziono treningu o podanym ID dla tego u≈ºytkownika"
                ));


        existingTraining.setDate(trainingDTO.date()); // Najpierw zmieniasz date w istniejƒÖcym obiekcie, zanim zapiszesz go w repozytorium, to standardowa aktualizacja encji.


        //Zastƒôpuje stare ƒáwiczenia nowymi, tak ≈ºeby Hibernate poprawnie usuwa≈Ç te usuniƒôte.
        List<TrainingExercise> newExercises = createExercise(trainingDTO, existingTraining);
        if(existingTraining.getExercises() == null){
            existingTraining.setExercises(newExercises);
        }else{
            existingTraining.getExercises().clear();
            existingTraining.getExercises().addAll(newExercises);
        }

        calculateTiS(existingTraining);


        trainingRepository.save(existingTraining);

        List<TrainingExerciseDTO> getExercise = getExercise(existingTraining);

        return new TrainingDTO(
                existingTraining.getId(),
                userId,
                existingTraining.getNote(),
                existingTraining.getDate(),
                existingTraining.getCreatedAt(),
                getExercise

        );
    }

    public List<TrainingExercise> createExercise(TrainingDTO trainingDTO, Training training) {
        return trainingDTO.exercises().stream()
                .map(dto -> TrainingExercise.builder()
                        .id(dto.id())
                        .exerciseCategory(dto.exerciseCategory())
                        .amount(dto.amount())
                        .duration(dto.duration())
                        .trainingAssigned(training)
                        .build()
                )
                .collect(Collectors.toList());
    }


    public List<TrainingExerciseDTO> getExercise(Training training) {
        List<TrainingExercise> exercises = training.getExercises();
        if (exercises == null) {
            return Collections.emptyList();
        }
        return exercises.stream().map(
                        exercise -> new TrainingExerciseDTO(
                                exercise.getId(),
                                exercise.getExerciseCategory(),
                                exercise.getAmount(),
                                exercise.getDuration()
                        ))
                .collect(Collectors.toList());
    }


    public void deleteTraining(Long trainingId, Long userId) {
        Training training = trainingRepository.findTrainingByIdAndUserAssigned_Id(trainingId, userId)
                .orElseThrow(() -> new TrainingForUserNotFoundException(
                        "Nie znaleziono treningu o podanym ID dla tego u≈ºytkownika"
                ));
        trainingRepository.delete(training);

    }


    public TrainingStatisticsDTO getStatisticsForUserId(Long userId) {
        List<Training> trainings = trainingRepository.findAllByUserAssigned_Id(userId);

        if (trainings.isEmpty()) {
            return new TrainingStatisticsDTO(0, 0, 0);
        }


        //≈õrednia czasu ca≈Çego treningu -> sumujemy czas wszystkich ƒáwicze≈Ñ w treningu, potem ≈õrednia po treningach
        double averageDuration = trainings.stream()
                .mapToDouble(t -> t.getExercises().stream()
                        .mapToInt(TrainingExercise::getDuration)
                        .sum()
                )
                .average()
                .orElse(0.0);

        //≈õrednia liczby powt√≥rze≈Ñ -> sumujemy wszystkie ƒáwiczenia w treningu, potem ≈õrednia po treningach
        double averageAmount = trainings.stream()
                .mapToDouble(t->t.getExercises().stream()
                        .mapToInt(TrainingExercise::getAmount)
                        .sum()
                )
                .average()
                .orElse(0.0);

        double averageIntensityScore = trainings.stream()
                .mapToDouble(Training::getIntensityScore)
                .average()
                .orElse(0.0);

        return new TrainingStatisticsDTO(averageDuration, averageAmount, averageIntensityScore);
    }

    public List<TrainingDTO> getTrainingsForUserByEmail(String email) {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException("Nie znaleziono u≈ºytkownika po emailu " + email));
        List<Training> trainings = trainingRepository.findAllByUserAssigned_Id(user.getId());

        return trainings.stream()
                .map(this::mapToTrainingDTO)
                .collect(Collectors.toList());
    }

    private TrainingDTO mapToTrainingDTO(Training training) {
        return new TrainingDTO(
                training.getId(),
                training.getUserAssigned().getId(),
                training.getNote(),
                training.getDate(),
                training.getCreatedAt(),
                getExercise(training)
        );
    }


    public void calculateTiS(Training training) {


        if (training.getExercises() == null || training.getExercises().isEmpty()) {
            training.setIntensityScore(0);
            training.setIntensityScoreMessage("Brak ƒáwicze≈Ñ w treningu");
            return;
        }


        int totalDuration = training.getExercises().stream()
                .mapToInt(TrainingExercise::getDuration)
                .sum();
        int totalAmount = training.getExercises().stream()
                .mapToInt(TrainingExercise::getAmount)
                .sum();

        // Math.min(..., 100) = maksymalnie 100, Math.max(0, ...) = minimalnie 0
        // Najpierw ograniczam g√≥rnƒÖ granicƒô, potem dolnƒÖ, wynik zawsze w przedziale 0‚Äì100


        // Normalizacja czasu i ilo≈õci powt√≥rze≈Ñ do zakresu 0‚Äì1
        // 80 minut i 500 powt√≥rze≈Ñ to maksymalne warto≈õci przy pe≈Çnym wyniku
        double calculateDuration = Math.min(totalDuration / 60.0, 1.0);
        double calculateAmount = Math.min(totalAmount / 400.0 , 1.0);

        double TiS = (calculateDuration * 0.5 + calculateAmount * 0.5) * 100;
        String feedback;

        if (TiS < 40) feedback = "Lekki Trening";
        else if (TiS < 70) feedback = "Dobry trening";
        else feedback = "Bardzo dobry trening";


        training.setIntensityScore(TiS);
        training.setIntensityScoreMessage(feedback);



        /*
            Na frontendzie dodac:  Wska≈∫nik intensywno≈õci treningu Wz√≥r: nowy wzor, Wz√≥r: nowy wzor + usunac "Przyk≈Çad"
            Zmienic uklad paneli, zmienic kolory


         */
    }
}
package com.trainify.trainifybackend.user.controller;


import com.trainify.trainifybackend.user.dto.UserRegisterLoginDTO;
import com.trainify.trainifybackend.user.service.UserService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

@RequiredArgsConstructor
@RestController
public class UserController {

    private final UserService userService;


    @PostMapping("/register")
    public ResponseEntity<UserRegisterLoginDTO> registerUser(@RequestBody @Valid UserRegisterLoginDTO userRegisterLoginDTO) {
        return ResponseEntity.ok(userService.registerUser(userRegisterLoginDTO));
    }

    @PostMapping("/login")
    public ResponseEntity<UserRegisterLoginDTO> loginUser(@RequestBody @Valid UserRegisterLoginDTO userLogin) {
        return ResponseEntity.ok(userService.loginUser(userLogin.email(), userLogin.password()));
    }
}

package com.trainify.trainifybackend.user.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;


public record UserRegisterLoginDTO(
        Long id,
        String username,
        @NotBlank
        String password,

        @Email
        String email,

        String jwtToken

) {
}
package com.trainify.trainifybackend.user.model;

import com.trainify.trainifybackend.training.model.Training;
import jakarta.persistence.*;
import lombok.*;

import java.time.LocalDateTime;
import java.util.List;

@Entity
@Table(name = "users")
@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Builder
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;


    private String username;
    private String password;
    private String email;
    private LocalDateTime createdAt;


    @OneToMany(mappedBy = "userAssigned", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Training> trainings;
}
package com.trainify.trainifybackend.user.repository;

import com.trainify.trainifybackend.user.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {

    Optional<User>findByEmail(String email); // metoda do znajdowania u≈ºytkownika po nazwie u≈ºytkownika lub emailu



    boolean existsByUsername(String username); // metoda do sprawdzania czy istnieje u≈ºytkownik o danej nazwie u≈ºytkownika
    boolean existsByEmail(String email); // metoda do sprawdzania czy istnieje u≈ºytkownik o danym emailu
}
package com.trainify.trainifybackend.user.service;

import com.trainify.trainifybackend.exception.EmailAlreadyExistsException;
import com.trainify.trainifybackend.exception.UserNotFoundException;
import com.trainify.trainifybackend.exception.UsernameAlreadyExistsException;
import com.trainify.trainifybackend.exception.WrongPasswordException;
import com.trainify.trainifybackend.security.service.JwtService;
import com.trainify.trainifybackend.user.dto.UserRegisterLoginDTO;
import com.trainify.trainifybackend.user.model.User;
import com.trainify.trainifybackend.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Service
@RequiredArgsConstructor
public class UserService {


    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtService jwtService;
    private final AuthenticationManager authenticationManager;


    public UserRegisterLoginDTO registerUser(UserRegisterLoginDTO userRegisterLoginDTO) {

        if (userRepository.existsByUsername(userRegisterLoginDTO.username())) {
            throw new UsernameAlreadyExistsException("Nazwa u≈ºytkownika jest ju≈º zajƒôta");
        }

        if (userRepository.existsByEmail(userRegisterLoginDTO.email())) {
            throw new EmailAlreadyExistsException("Email jest ju≈º zajƒôty");
        }


        User user = User.builder()
                .username(userRegisterLoginDTO.username())
                .email(userRegisterLoginDTO.email())
                .password(passwordEncoder.encode(userRegisterLoginDTO.password())) // hashowanie has≈Ça
                .createdAt(LocalDateTime.now())
                .build();
        User savedUser = userRepository.save(user);

        String jwtToken = jwtService.generateToken(
                new org.springframework.security.core.userdetails.User(
                        savedUser.getEmail(),
                        savedUser.getPassword(),
                        List.of()
                )
        );

        return new UserRegisterLoginDTO(user.getId(),savedUser.getUsername(), null, savedUser.getEmail(), jwtToken);

    }

    public UserRegisterLoginDTO loginUser(String email, String rawPassword) {
        try {
            authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(email, rawPassword)
            );
        } catch (AuthenticationException e) {
            throw new WrongPasswordException("Nieprawid≈Çowy email lub has≈Ço");
        }


        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException("Nie znaleziono u≈ºytkownika"));


        UserDetails userDetails = new org.springframework.security.core.userdetails.User(
                user.getEmail(),
                user.getPassword(),
                List.of()
        );
        String jwtToken = jwtService.generateToken(userDetails);

        return new UserRegisterLoginDTO(user.getId(),user.getUsername(), null, user.getEmail(), jwtToken);
    }


    public Optional<User> getUserById(Long userId) {
        return userRepository.findById(userId);
    }


}
package com.trainify.trainifybackend;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class TrainifyBackendApplication {

	public static void main(String[] args) {
		SpringApplication.run(TrainifyBackendApplication.class, args);
	}

}
package com.trainify.trainifybackend.training.service;
